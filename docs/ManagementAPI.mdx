---
id: management-api
title: Management API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The primitive API that provides full support for Casbin policy management.

## Filtered API

Almost all filtered api has the same parameters ``(fieldIndex int, fieldValues ...string)``. `fieldIndex` is the index where matching start, `fieldValues` denotes the values result should have. Note that empty string in fieldValues could be any word.

Example:

```csv
p, alice, book, read
p, bob, book, read
p, bob, book, write
p, alice, pen, get
p, bob, pen ,get
```

```go
e.GetFilteredPolicy(1, "book") // will return: [[alice book read] [bob book read] [bob book write]]

e.GetFilteredPolicy(1, "book", "read") // will return: [[alice book read] [bob book read]]

e.GetFilteredPolicy(0, "alice", "", "read") // will return: [[alice book read]]

e.GetFilteredPolicy(0, "alice") // will return: [[alice book read] [alice pen get]]
```

## Reference

global variable `e` is Enforcer instance.

<Tabs>

<TabItem value="Go" label="Go" default>

```go
e, err := NewEnforcer("examples/rbac_model.conf", "examples/rbac_policy.csv")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const e = await newEnforcer('examples/rbac_model.conf', 'examples/rbac_policy.csv')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$e = new Enforcer('examples/rbac_model.conf', 'examples/rbac_policy.csv');
```

</TabItem>

<TabItem value="Python" label="Python">

```python
e = casbin.Enforcer("examples/rbac_model.conf", "examples/rbac_policy.csv")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let mut e = Enforce::new("examples/rbac_model.conf", "examples/rbac_policy.csv").await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
Enforcer e = new Enforcer("examples/rbac_model.conf", "examples/rbac_policy.csv");
```

</TabItem>

</Tabs>

### `Enforce()`

Enforce decides whether a "subject" can access a "object" with the operation "action", input parameters are usually: (sub, obj, act).

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
ok, err := e.Enforce(request)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const ok = await e.enforce(request);
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$ok = $e->enforcer($request);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
ok = e.enforcer(request)
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean ok = e.enforce(request);
```

</TabItem>

</Tabs>

### `EnforceWithMatcher()`

EnforceWithMatcher use a custom matcher to decides whether a "subject" can access a "object" with the operation "action", input parameters are usually: (matcher, sub, obj, act), use model matcher by default when matcher is "".

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
ok, err := e.EnforceWithMatcher(matcher, request)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$ok = $e->enforceWithMatcher($matcher, $request);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
ok = e.enforce_with_matcher(matcher, request)
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean ok = e.enforceWithMatcher(matcher, request);
```

</TabItem>

</Tabs>

### `EnforceEx()`

EnforceEx explain enforcement by informing matched rules.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
ok, reason, err := e.EnforceEx(request)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const ok = await e.enforceEx(request);
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
list($ok, $reason) = $e->enforceEx($request);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
ok, reason = e.enforce_ex(request)
```

</TabItem>

</Tabs>

### `EnforceExWithMatcher()`

EnforceExWithMatcher use a custom matcher and explain enforcement by informing matched rules.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
ok, reason, err := e.EnforceExWithMatcher(matcher, request)
```

</TabItem>

</Tabs>

### `BatchEnforce()`

BatchEnforce enforces each request and returns result in a bool array

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
boolArray, err := e.BatchEnforce(requests)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const boolArray = await e.batchEnforce(requests);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<Boolean> boolArray = e.batchEnforce(requests);
```

</TabItem>

</Tabs>

### `GetAllSubjects()`

GetAllSubjects gets the list of subjects that show up in the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allSubjects := e.GetAllSubjects()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allSubjects = await e.getAllSubjects()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allSubjects = $e->getAllSubjects();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_subjects = e.get_all_subjects()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allSubjects = e.GetAllSubjects();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_subjects = e.get_all_subjects();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allSubjects = e.getAllSubjects();
```

</TabItem>

</Tabs>

### `GetAllNamedSubjects()`

GetAllNamedSubjects gets the list of subjects that show up in the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allNamedSubjects := e.GetAllNamedSubjects("p")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allNamedSubjects = await e.getAllNamedSubjects('p')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allNamedSubjects = $e->getAllNamedSubjects("p");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_named_subjects = e.get_all_named_subjects("p")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allNamedSubjects = e.GetAllNamedSubjects("p");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_named_subjects = e.get_all_named_subjects("p");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allNamedSubjects = e.getAllNamedSubjects("p");
```

</TabItem>

</Tabs>

### `GetAllObjects()`

GetAllObjects gets the list of objects that show up in the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allObjects := e.GetAllObjects()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allObjects = await e.getAllObjects()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allObjects = $e->getAllObjects();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_objects = e.get_all_objects()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allObjects = e.GetAllObjects();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_objects = e.get_all_objects();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allObjects = e.getAllObjects();
```

</TabItem>

</Tabs>

### `GetAllNamedObjects()`

GetAllNamedObjects gets the list of objects that show up in the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allNamedObjects := e.GetAllNamedObjects("p")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allNamedObjects = await e.getAllNamedObjects('p')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allNamedObjects = $e->getAllNamedObjects("p");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_named_objects = e.get_all_named_objects("p")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allNamedObjects = e.GetAllNamedObjects("p");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_named_objects = e.get_all_named_objects("p");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allNamedObjects = e.getAllNamedObjects("p");
```

</TabItem>

</Tabs>

### `GetAllActions()`

GetAllActions gets the list of actions that show up in the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allActions := e.GetAllActions()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allActions = await e.getAllActions()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allActions = $e->getAllActions();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_actions = e.get_all_actions()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allActions = e.GetAllActions();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_actions = e.get_all_actions();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allActions = e.getAllActions();
```

</TabItem>

</Tabs>

### `GetAllNamedActions()`

GetAllNamedActions gets the list of actions that show up in the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allNamedActions := e.GetAllNamedActions("p")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allNamedActions = await e.getAllNamedActions('p')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allNamedActions = $e->getAllNamedActions("p");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_named_actions = e.get_all_named_actions("p")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allNamedActions = e.GetAllNamedActions("p");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_named_actions = e.get_all_named_actions("p");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allNamedActions = e.getAllNamedActions("p");
```

</TabItem>

</Tabs>

### `GetAllRoles()`

GetAllRoles gets the list of roles that show up in the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```
allRoles = e.GetAllRoles()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allRoles = await e.getAllRoles()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allRoles = $e->getAllRoles();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_roles = e.get_all_roles()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allRoles = e.GetAllRoles();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_roles = e.get_all_roles();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allRoles = e.getAllRoles();
```

</TabItem>

</Tabs>

### `GetAllNamedRoles()`

GetAllNamedRoles gets the list of roles that show up in the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
allNamedRoles := e.GetAllNamedRoles("g")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const allNamedRoles = await e.getAllNamedRoles('g')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$allNamedRoles = $e->getAllNamedRoles('g');
```

</TabItem>

<TabItem value="Python" label="Python">

```python
all_named_roles = e.get_all_named_roles("g")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var allNamedRoles = e.GetAllNamedRoles("g");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let all_named_roles = e.get_all_named_roles("g");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<String> allNamedRoles = e.getAllNamedRoles("g");
```

</TabItem>

</Tabs>

### `GetPolicy()`

GetPolicy gets all the authorization rules in the policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
policy = e.GetPolicy()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const policy = await e.getPolicy()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$policy = $e->getPolicy();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
policy = e.get_policy()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var policy = e.GetPolicy();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let policy = e.get_policy();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> policy = e.getPolicy();
```

</TabItem>

</Tabs>


### `GetFilteredPolicy()`

GetFilteredPolicy gets all the authorization rules in the policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
filteredPolicy := e.GetFilteredPolicy(0, "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const filteredPolicy = await e.getFilteredPolicy(0, 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$filteredPolicy = $e->getFilteredPolicy(0, "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
filtered_policy = e.get_filtered_policy(0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var filteredPolicy = e.GetFilteredPolicy(0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let filtered_policy = e.get_filtered_policy(0, vec!["alice".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> filteredPolicy = e.getFilteredPolicy(0, "alice");
```

</TabItem>

</Tabs>

### `GetNamedPolicy()`

GetNamedPolicy gets all the authorization rules in the named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
namedPolicy := e.GetNamedPolicy("p")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const namedPolicy = await e.getNamedPolicy('p')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$namedPolicy = $e->getNamedPolicy("p");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
named_policy = e.get_named_policy("p")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var namedPolicy = e.GetNamedPolicy("p");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let named_policy = e.get_named_policy("p");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> namedPolicy = e.getNamedPolicy("p");
```

</TabItem>

</Tabs>


### `GetFilteredNamedPolicy()`

GetFilteredNamedPolicy gets all the authorization rules in the named policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
filteredNamedPolicy = e.GetFilteredNamedPolicy("p", 0, "bob")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const filteredNamedPolicy = await e.getFilteredNamedPolicy('p', 0, 'bob')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$filteredNamedPolicy = $e->getFilteredNamedPolicy("p", 0, "bob");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
filtered_named_policy = e.get_filtered_named_policy("p", 0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var filteredNamedPolicy = e.GetFilteredNamedPolicy("p", 0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let filtered_named_policy = e.get_filtered_named_policy("p", 0, vec!["bob".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> filteredNamedPolicy = e.getFilteredNamedPolicy("p", 0, "bob");
```

</TabItem>

</Tabs>

### `GetGroupingPolicy()`

GetGroupingPolicy gets all the role inheritance rules in the policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
groupingPolicy := e.GetGroupingPolicy()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const groupingPolicy = await e.getGroupingPolicy()
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$groupingPolicy = $e->getGroupingPolicy();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
grouping_policy = e.get_grouping_policy()
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var groupingPolicy = e.GetGroupingPolicy();
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let grouping_policy = e.get_grouping_policy();
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> groupingPolicy = e.getGroupingPolicy();
```

</TabItem>

</Tabs>

### `GetFilteredGroupingPolicy()`

GetFilteredGroupingPolicy gets all the role inheritance rules in the policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
filteredGroupingPolicy := e.GetFilteredGroupingPolicy(0, "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const filteredGroupingPolicy = await e.getFilteredGroupingPolicy(0, 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$filteredGroupingPolicy = $e->getFilteredGroupingPolicy(0, "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
filtered_grouping_policy = e.get_filtered_grouping_policy(0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var filteredGroupingPolicy = e.GetFilteredGroupingPolicy(0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let filtered_grouping_policy = e.get_filtered_grouping_policy(0, vec!["alice".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> filteredGroupingPolicy = e.getFilteredGroupingPolicy(0, "alice");
```

</TabItem>

</Tabs>

### `GetNamedGroupingPolicy()`

GetNamedGroupingPolicy gets all the role inheritance rules in the policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
namedGroupingPolicy := e.GetNamedGroupingPolicy("g")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const namedGroupingPolicy = await e.getNamedGroupingPolicy('g')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$namedGroupingPolicy = $e->getNamedGroupingPolicy("g");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
named_grouping_policy = e.get_named_grouping_policy("g")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var namedGroupingPolicy = e.GetNamedGroupingPolicy("g");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let named_grouping_policy = e.get_named_grouping_policy("g");
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> namedGroupingPolicy = e.getNamedGroupingPolicy("g");
```

</TabItem>

</Tabs>

### `GetFilteredNamedGroupingPolicy()`

GetFilteredNamedGroupingPolicy gets all the role inheritance rules in the policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
namedGroupingPolicy := e.GetFilteredNamedGroupingPolicy("g", 0, "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const namedGroupingPolicy = await e.getFilteredNamedGroupingPolicy('g', 0, 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$namedGroupingPolicy = $e->getFilteredNamedGroupingPolicy("g", 0, "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
named_grouping_policy = e.get_filtered_named_grouping_policy("g", 0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var namedGroupingPolicy = e.GetFilteredNamedGroupingPolicy("g", 0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let named_grouping_policy = e.get_filtered_named_groupingPolicy("g", 0, vec!["alice".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> filteredNamedGroupingPolicy = e.getFilteredNamedGroupingPolicy("g", 0, "alice");
```

</TabItem>

</Tabs>

### `HasPolicy()`

HasPolicy determines whether an authorization rule exists.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
hasPolicy := e.HasPolicy("data2_admin", "data2", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const hasPolicy = await e.hasPolicy('data2_admin', 'data2', 'read')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$hasPolicy = $e->hasPolicy('data2_admin', 'data2', 'read');
```

</TabItem>

<TabItem value="Python" label="Python">

```python
has_policy = e.has_policy("data2_admin", "data2", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var hasPolicy = e.HasPolicy("data2_admin", "data2", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let has_policy = e.has_policy(vec!["data2_admin".to_owned(), "data2".to_owned(), "read".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean hasPolicy = e.hasPolicy("data2_admin", "data2", "read");
```

</TabItem>

</Tabs>

### `HasNamedPolicy()`

HasNamedPolicy determines whether a named authorization rule exists.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
hasNamedPolicy := e.HasNamedPolicy("p", "data2_admin", "data2", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const hasNamedPolicy = await e.hasNamedPolicy('p', 'data2_admin', 'data2', 'read')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$hasNamedPolicy = $e->hasNamedPolicy("p", "data2_admin", "data2", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
has_named_policy = e.has_named_policy("p", "data2_admin", "data2", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var hasNamedPolicy = e.HasNamedPolicy("p", "data2_admin", "data2", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let has_named_policy = e.has_named_policy("p", vec!["data2_admin".to_owned(), "data2".to_owned(), "read".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean hasNamedPolicy = e.hasNamedPolicy("p", "data2_admin", "data2", "read");
```

</TabItem>

</Tabs>

### `AddPolicy()`

AddPolicy adds an authorization rule to the current policy.
If the rule already exists, the function returns false and the rule will not be added.
Otherwise the function returns true by adding the new rule.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
added := e.AddPolicy('eve', 'data3', 'read')
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['eve', 'data3', 'read']
const added = await e.addPolicy(...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$added = $e->addPolicy('eve', 'data3', 'read');
```

</TabItem>

<TabItem value="Python" label="Python">

```python
added = e.add_policy("eve", "data3", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var added = e.AddPolicy("eve", "data3", "read");
or
var added = await e.AddPolicyAsync("eve", "data3", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let added = e.add_policy(vec!["eve".to_owned(), "data3".to_owned(), "read".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean added = e.addPolicy("eve", "data3", "read");
```

</TabItem>

</Tabs>

### `AddPolicies()`

AddPolicies adds authorization rules to the current policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is added to the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is added to the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"jack", "data4", "read"},
	[]string {"katy", "data4", "write"},
	[]string {"leyo", "data4", "read"},
	[]string {"ham", "data4", "write"},
}

areRulesAdded := e.AddPolicies(rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesAdded = await e.addPolicies(rules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_added = e.add_policies(rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
	vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_added = e.add_policies(rules).await?
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] rules = {
	{"jack", "data4", "read"},
	{"katy", "data4", "write"},
	{"leyo", "data4", "read"},
	{"ham", "data4", "write"},
};

boolean areRulesAdded = e.addPolicies(rules);
```

</TabItem>

</Tabs>

### `AddNamedPolicy()`

AddNamedPolicy adds an authorization rule to the current named policy.
If the rule already exists, the function returns false and the rule will not be added.
Otherwise the function returns true by adding the new rule.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
added := e.AddNamedPolicy("p", "eve", "data3", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['eve', 'data3', 'read']
const added = await e.addNamedPolicy('p', ...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$added = $e->addNamedPolicy("p", "eve", "data3", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
added = e.add_named_policy("p", "eve", "data3", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var added = e.AddNamedPolicy("p", "eve", "data3", "read");
or
var added = await e.AddNamedPolicyAsync("p", "eve", "data3", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let added = e.add_named_policy("p", vec!["eve".to_owned(), "data3".to_owned(), "read".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean added = e.addNamedPolicy("p", "eve", "data3", "read");
```

</TabItem>

</Tabs>

### `AddNamedPolicies()`

AddNamedPolicies adds authorization rules to the current named policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is added to the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is added to the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"jack", "data4", "read"},
	[]string {"katy", "data4", "write"},
	[]string {"leyo", "data4", "read"},
	[]string {"ham", "data4", "write"},
}

areRulesAdded := e.AddNamedPolicies("p", rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesAdded = await e.addNamedPolicies('p', rules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_added = e.add_named_policies("p", rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
	vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_added := e.add_named_policies("p", rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> rules = Arrays.asList(
	Arrays.asList("jack", "data4", "read"),
	Arrays.asList("katy", "data4", "write"),
	Arrays.asList("leyo", "data4", "read"),
	Arrays.asList("ham", "data4", "write")
);
boolean areRulesAdded = e.addNamedPolicies("p", rules);
```

</TabItem>

</Tabs>

### `RemovePolicy()`

RemovePolicy removes an authorization rule from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemovePolicy("alice", "data1", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removePolicy(...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removePolicy("alice", "data1", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_policy("alice", "data1", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemovePolicy("alice", "data1", "read");
or
var removed = await e.RemovePolicyAsync("alice", "data1", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_policy(vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removePolicy("alice", "data1", "read");
```

</TabItem>

</Tabs>

### `RemovePolicies()`

RemovePolicies removes authorization rules from the current policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is removed from the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is removed from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"jack", "data4", "read"},
	[]string {"katy", "data4", "write"},
	[]string {"leyo", "data4", "read"},
	[]string {"ham", "data4", "write"},
}

areRulesRemoved := e.RemovePolicies(rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesRemoved = await e.removePolicies(rules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_removed = e.remove_policies(rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
	vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_removed = e.remove_policies(rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] rules = {
	{"jack", "data4", "read"},
	{"katy", "data4", "write"},
	{"leyo", "data4", "read"},
	{"ham", "data4", "write"},
};
boolean areRulesRemoved = e.removePolicies(rules);
```

</TabItem>

</Tabs>

### `RemoveFilteredPolicy()`

RemoveFilteredPolicy removes an authorization rule from the current policy, field filters can be specified.
RemovePolicy removes an authorization rule from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveFilteredPolicy(0, "alice", "data1", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeFilteredPolicy(0, ...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeFilteredPolicy(0, "alice", "data1", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_filtered_policy(0, "alice", "data1", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveFilteredPolicy("alice", "data1", "read");
or
var removed = await e.RemoveFilteredPolicyAsync("alice", "data1", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_filtered_policy(0, vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeFilteredPolicy(0, "alice", "data1", "read");
```

</TabItem>

</Tabs>

### `RemoveNamedPolicy()`

RemoveNamedPolicy removes an authorization rule from the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveNamedPolicy("p", "alice", "data1", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeNamedPolicy('p', ...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeNamedPolicy("p", "alice", "data1", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_named_policy("p", "alice", "data1", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveNamedPolicy("p", "alice", "data1", "read");
or
var removed = await e.RemoveNamedPolicyAsync("p", "alice", "data1", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_named_policy("p", vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeNamedPolicy("p", "alice", "data1", "read");
```

</TabItem>

</Tabs>

### `RemoveNamedPolicies()`

RemoveNamedPolicies removes authorization rules from the current named policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is removed from the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is removed from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"jack", "data4", "read"},
	[]string {"katy", "data4", "write"},
	[]string {"leyo", "data4", "read"},
	[]string {"ham", "data4", "write"},
}

areRulesRemoved := e.RemoveNamedPolicies("p", rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesRemoved = await e.removeNamedPolicies('p', rules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_removed = e.remove_named_policies("p", rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
	vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
	vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let areRulesRemoved = e.remove_named_policies("p", rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
List<List<String>> rules = Arrays.asList(
	Arrays.asList("jack", "data4", "read"),
	Arrays.asList("katy", "data4", "write"),
	Arrays.asList("leyo", "data4", "read"),
	Arrays.asList("ham", "data4", "write")
);
boolean areRulesRemoved = e.removeNamedPolicies("p", rules);
```

</TabItem>

</Tabs>

### `RemoveFilteredNamedPolicy()`

RemoveFilteredNamedPolicy removes an authorization rule from the current named policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveFilteredNamedPolicy("p", 0, "alice", "data1", "read")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeFilteredNamedPolicy('p', 0, ...p)
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeFilteredNamedPolicy("p", 0, "alice", "data1", "read");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_filtered_named_policy("p", 0, "alice", "data1", "read")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveFilteredNamedPolicy("p", 0, "alice", "data1", "read");
or
var removed = e.RemoveFilteredNamedPolicyAync("p", 0, "alice", "data1", "read");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_filtered_named_policy("p", 0, vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeFilteredNamedPolicy("p", 0, "alice", "data1", "read");
```

</TabItem>

</Tabs>

### `HasGroupingPolicy()`

HasGroupingPolicy determines whether a role inheritance rule exists.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
has := e.HasGroupingPolicy("alice", "data2_admin")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const has = await e.hasGroupingPolicy('alice', 'data2_admin')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$has = $e->hasGroupingPolicy("alice", "data2_admin");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
has = e.has_grouping_policy("alice", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var has = e.HasGroupingPolicy("alice", "data2_admin");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let has = e.has_grouping_policy(vec!["alice".to_owned(), "data2_admin".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean has = e.hasGroupingPolicy("alice", "data2_admin");
```

</TabItem>

</Tabs>

### `HasNamedGroupingPolicy()`

HasNamedGroupingPolicy determines whether a named role inheritance rule exists.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
has := e.HasNamedGroupingPolicy("g", "alice", "data2_admin")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const has = await e.hasNamedGroupingPolicy('g', 'alice', 'data2_admin')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$has = $e->hasNamedGroupingPolicy("g", "alice", "data2_admin");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
has = e.has_named_grouping_policy("g", "alice", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var has = e.HasNamedGroupingPolicy("g", "alice", "data2_admin");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let has = e.has_named_grouping_policy("g", vec!["alice".to_owned(), "data2_admin".to_owned()]);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean has = e.hasNamedGroupingPolicy("g", "alice", "data2_admin");
```

</TabItem>

</Tabs>

### `AddGroupingPolicy()`

AddGroupingPolicy adds a role inheritance rule to the current policy.
If the rule already exists, the function returns false and the rule will not be added.
Otherwise the function returns true by adding the new rule.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
added := e.AddGroupingPolicy("group1", "data2_admin")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const added = await e.addGroupingPolicy('group1', 'data2_admin')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$added = $e->addGroupingPolicy("group1", "data2_admin");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
added = e.add_grouping_policy("group1", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var added = e.AddGroupingPolicy("group1", "data2_admin");
or
var added = await e.AddGroupingPolicyAsync("group1", "data2_admin");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let added = e.add_grouping_policy(vec!["group1".to_owned(), "data2_admin".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean added = e.addGroupingPolicy("group1", "data2_admin");
```

</TabItem>

</Tabs>

### `AddGroupingPolicies()`

AddGroupingPolicies adds role inheritance rules to the current policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is added to the current policy.
If all authorization the rules are consistent with the policy rules, the function returns true and each policy rule is added to the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"ham", "data4_admin"},
	[]string {"jack", "data5_admin"},
}

areRulesAdded := e.AddGroupingPolicies(rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesAdded = await e.addGroupingPolicies(groupingRules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_added = e.add_grouping_policies(rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["ham".to_owned(), "data4_admin".to_owned()],
	vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let areRulesAdded = e.add_grouping_policies(rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] groupingRules = {
	{"ham", "data4_admin"},
	{"jack", "data5_admin"}
};
boolean areRulesAdded = e.addGroupingPolicies(groupingRules);
```

</TabItem>

</Tabs>

### `AddNamedGroupingPolicy()`

AddNamedGroupingPolicy adds a named role inheritance rule to the current policy.
If the rule already exists, the function returns false and the rule will not be added.
Otherwise the function returns true by adding the new rule.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
added := e.AddNamedGroupingPolicy("g", "group1", "data2_admin")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const added = await e.addNamedGroupingPolicy('g', 'group1', 'data2_admin')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$added = $e->addNamedGroupingPolicy("g", "group1", "data2_admin");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
added = e.add_named_grouping_policy("g", "group1", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var added = e.AddNamedGroupingPolicy("g", "group1", "data2_admin");
or
var added = await e.AddNamedGroupingPolicyAsync("g", "group1", "data2_admin");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let added = e.add_named_grouping_policy("g", vec!["group1".to_owned(), "data2_admin".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean added = e.addNamedGroupingPolicy("g", "group1", "data2_admin");
```

</TabItem>

</Tabs>

### `AddNamedGroupingPolicies()`

AddNamedGroupingPolicies adds named role inheritance rules to the current policy.
The operation is atomic in nature. 
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is added to the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is added to the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"ham", "data4_admin"},
	[]string {"jack", "data5_admin"},
}

areRulesAdded := e.AddNamedGroupingPolicies("g", rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesAdded = await e.addNamedGroupingPolicies('g', groupingRules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_added = e.add_named_grouping_policies("g", rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["ham".to_owned(), "data4_admin".to_owned()],
	vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_added = e.add_named_grouping_policies("g", rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] groupingRules = {
	{"ham", "data4_admin"},
	{"jack", "data5_admin"}
};
boolean areRulesAdded = e.addNamedGroupingPolicies("g", groupingRules);
```

</TabItem>

</Tabs>

### `RemoveGroupingPolicy()`

RemoveGroupingPolicy removes a role inheritance rule from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveGroupingPolicy("alice", "data2_admin")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const removed = await e.removeGroupingPolicy('alice', 'data2_admin')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeGroupingPolicy("alice", "data2_admin");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_grouping_policy("alice", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveGroupingPolicy("alice", "data2_admin");
or
var removed = await e.RemoveGroupingPolicyAsync("alice", "data2_admin");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_grouping_policy(vec!["alice".to_owned(), "data2_admin".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeGroupingPolicy("alice", "data2_admin");
```

</TabItem>

</Tabs>

### `RemoveGroupingPolicies()`

RemoveGroupingPolicies removes role inheritance rules from the current policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is removed from the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is removed from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
				[]string {"ham", "data4_admin"},
				[]string {"jack", "data5_admin"},
		}

areRulesRemoved := e.RemoveGroupingPolicies(rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesRemoved = await e.removeGroupingPolicies(groupingRules);
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["ham".to_owned(), "data4_admin".to_owned()],
	vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_removed = e.remove_grouping_policies(rules).await?;
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_removed = e.remove_grouping_policies(rules)
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] groupingRules = {
	{"ham", "data4_admin"},
	{"jack", "data5_admin"}
};
boolean areRulesRemoved = e.removeGroupingPolicies(groupingRules);
```

</TabItem>

</Tabs>

### `RemoveFilteredGroupingPolicy()`

RemoveFilteredGroupingPolicy removes a role inheritance rule from the current policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveFilteredGroupingPolicy(0, "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const removed = await e.removeFilteredGroupingPolicy(0, 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeFilteredGroupingPolicy(0, "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_filtered_grouping_policy(0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveFilteredGroupingPolicy(0, "alice");
or
var removed = await e.RemoveFilteredGroupingPolicyAsync(0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_filtered_grouping_policy(0, vec!["alice".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeFilteredGroupingPolicy(0, "alice");
```

</TabItem>

</Tabs>

### `RemoveNamedGroupingPolicy()`

RemoveNamedGroupingPolicy removes a role inheritance rule from the current named policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveNamedGroupingPolicy("g", "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const removed = await e.removeNamedGroupingPolicy('g', 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeNamedGroupingPolicy("g", "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_named_grouping_policy("g", "alice", "data2_admin")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveNamedGroupingPolicy("g", "alice");
or 
var removed = await e.RemoveNamedGroupingPolicyAsync("g", "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_named_grouping_policy("g", vec!["alice".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeNamedGroupingPolicy("g", "alice");
```

</TabItem>

</Tabs>

### `RemoveNamedGroupingPolicies()`

RemoveNamedGroupingPolicies removes named role inheritance rules from the current policy.
The operation is atomic in nature.
Hence, if authorization rules consists of rules which are not consistent with the current policy, the function returns false and no policy rule is removed from the current policy.
If all the authorization rules are consistent with the policy rules, the function returns true and each policy rule is removed from the current policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
rules := [][] string {
	[]string {"ham", "data4_admin"},
	[]string {"jack", "data5_admin"},
}

areRulesRemoved := e.RemoveNamedGroupingPolicies("g", rules)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesRemoved = await e.removeNamedGroupingPolicies('g', groupingRules);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]
are_rules_removed = e.remove_named_grouping_policies("g", rules)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let rules = vec![
	vec!["ham".to_owned(), "data4_admin".to_owned()],
	vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_removed = e.remove_named_grouping_policies("g", rules).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
String[][] groupingRules = {
	{"ham", "data4_admin"},
	{"jack", "data5_admin"}
};
boolean areRulesRemoved = e.removeNamedGroupingPolicies("g", groupingRules);
```

</TabItem>

</Tabs>

### `RemoveFilteredNamedGroupingPolicy()`

RemoveFilteredNamedGroupingPolicy removes a role inheritance rule from the current named policy, field filters can be specified.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
removed := e.RemoveFilteredNamedGroupingPolicy("g", 0, "alice")
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const removed = await e.removeFilteredNamedGroupingPolicy('g', 0, 'alice')
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
$removed = $e->removeFilteredNamedGroupingPolicy("g", 0, "alice");
```

</TabItem>

<TabItem value="Python" label="Python">

```python
removed = e.remove_filtered_named_grouping_policy("g", 0, "alice")
```

</TabItem>

<TabItem value=".NET" label=".NET">

```csharp
var removed = e.RemoveFilteredNamedGroupingPolicy("g", 0, "alice");
or
var removed = await e.RemoveFilteredNamedGroupingPolicyAsync("g", 0, "alice");
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
let removed = e.remove_filtered_named_groupingPolicy("g", 0, vec!["alice".to_owned()]).await?;
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean removed = e.removeFilteredNamedGroupingPolicy("g", 0, "alice");
```

</TabItem>

</Tabs>

### `UpdatePolicy()`

UpdatePolicy update a old policy to new policy.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
updated, err := e.UpdatePolicy([]string{"eve", "data3", "read"}, []string{"eve", "data3", "write"})
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const update = await e.updatePolicy(["eve", "data3", "read"], ["eve", "data3", "write"]);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
updated = e.update_policy(["eve", "data3", "read"], ["eve", "data3", "write"])
```

</TabItem>

<TabItem value="Java" label="Java">

```java
boolean updated = e.updatePolicy(Arrays.asList("eve", "data3", "read"), Arrays.asList("eve", "data3", "write"));
```

</TabItem>

</Tabs>

### `UpdatePolicies()`

UpdatePolicies updates all old policies to new policies.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
updated, err := e.UpdatePolicies([][]string{{"eve", "data3", "read"}, {"jack", "data3", "read"}}, [][]string{{"eve", "data3", "write"}, {"jack", "data3", "write"}})
```

</TabItem>

<TabItem value="Python" label="Python">

```python
old_rules = [["eve", "data3", "read"], ["jack", "data3", "read"]]
new_rules = [["eve", "data3", "write"], ["jack", "data3", "write"]]

updated = e.update_policies(old_rules, new_rules)
```

</TabItem>

</Tabs>

### `AddFunction()`

AddFunction adds a customized function.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
func CustomFunction(key1 string, key2 string) bool {
	if key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource" {
		return true
	} else if key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId" {
		return true
	} else {
		return false
	}
}

func CustomFunctionWrapper(args ...interface{}) (interface{}, error) {
	key1 := args[0].(string)
	key2 := args[1].(string)

	return bool(CustomFunction(key1, key2)), nil
}

e.AddFunction("keyMatchCustom", CustomFunctionWrapper)
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
function customFunction(key1, key2){
    if(key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource") {
        return true
    } else if(key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId") {
        return true
    } else {
        return false
    }
}

e.addFunction("keyMatchCustom", customFunction);
```

</TabItem>

<TabItem value="PHP" label="PHP">

```php
func customFunction($key1, $key2) {
	if ($key1 == "/alice_data2/myid/using/res_id" && $key2 == "/alice_data/:resource") {
		return true;
	} elseif ($key1 == "/alice_data2/myid/using/res_id" && $key2 == "/alice_data2/:id/using/:resId") {
		return true;
	} else {
		return false;
	}
}

func customFunctionWrapper(...$args){
	$key1 := $args[0];
	$key2 := $args[1];

	return customFunction($key1, $key2);
}

$e->addFunction("keyMatchCustom", customFunctionWrapper);
```

</TabItem>

<TabItem value="Python" label="Python">

```python
def custom_function(key1, key2):
    return ((key1 == "/alice_data2/myid/using/res_id" and key2 == "/alice_data/:resource") or (key1 == "/alice_data2/myid/using/res_id" and key2 == "/alice_data2/:id/using/:resId"))


e.add_function("keyMatchCustom", custom_function)
```

</TabItem>

<TabItem value="Rust" label="Rust">

```rust
fn custom_function(key1: STring, key2: String) {
	key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource" || key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId"
}


e.add_function("keyMatchCustom", custom_function);
```

</TabItem>

<TabItem value="Java" label="Java">

```java
public static class CustomFunc extends CustomFunction {
	@Override
	public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {
		String key1 = FunctionUtils.getStringValue(arg1, env);
		String key2 = FunctionUtils.getStringValue(arg2, env);
		if (key1.equals("/alice_data2/myid/using/res_id") && key2.equals("/alice_data/:resource")) {
			return AviatorBoolean.valueOf(true);
		} else if (key1.equals("/alice_data2/myid/using/res_id") && key2.equals("/alice_data2/:id/using/:resId")) {
			return AviatorBoolean.valueOf(true);
		} else {
			return AviatorBoolean.valueOf(false);
		}
	}

	@Override
	public String getName() {
		return "keyMatchCustom";
	}
}

FunctionTest.CustomFunc customFunc = new FunctionTest.CustomFunc();
e.addFunction(customFunc.getName(), customFunc);
```

</TabItem>

</Tabs>

### `LoadFilteredPolicy()`

LoadFilteredPolicy loads filtered policies from file/database.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
err := e.LoadFilteredPolicy()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const ok = await e.loadFilteredPolicy();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
class Filter:
    P = []
    G = []

adapter = casbin.persist.adapters.FilteredAdapter("rbac_with_domains_policy.csv")
e = casbin.Enforcer("rbac_with_domains_model.conf", adapter)
filter = Filter()
filter.P = ["", "domain1"]
filter.G = ["", "", "domain1"]
e.load_filtered_policy(filter)
```

</TabItem>

<TabItem value="Java" label="Java">

```java
e.loadFilteredPolicy(new String[] { "", "domain1" });
```

</TabItem>

</Tabs>

### `LoadIncrementalFilteredPolicy()`

LoadIncrementalFilteredPolicy append a filtered policy from file/database.

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
err := e.LoadIncrementalFilteredPolicy()
```

</TabItem>

<TabItem value="Node.js" label="Node.js">

```typescript
const ok = await e.loadIncrementalFilteredPolicy();
```

</TabItem>

<TabItem value="Python" label="Python">

```python
adapter = casbin.persist.adapters.FilteredAdapter("rbac_with_domains_policy.csv")
e = casbin.Enforcer("rbac_with_domains_model.conf", adapter)
filter = Filter()
filter.P = ["", "domain1"]
filter.G = ["", "", "domain1"]
e.load_increment_filtered_policy(filter)
```

</TabItem>

</Tabs>

### `UpdateGroupingPolicy()`

UpdateGroupingPolicy updates oldRule to newRulein `g` section

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
succeed, err : = e.UpdateGroupingPolicy([]string{"data3_admin", "data4_admin"}, []string{"admin", "data4_admin"})
```

</TabItem>

<TabItem value="Java" label="Java">

```Java
boolean succeed = e.updateGroupingPolicy(Arrays.asList("data3_admin", "data4_admin"), Arrays.asList("admin", "data4_admin"));
```

</TabItem>

</Tabs>

### `UpdateNamedGroupingPolicy()`

UpdateNamedGroupingPolicy updates oldRule named `ptype` to newRulein `g` section

For example:

<Tabs>

<TabItem value="Go" label="Go" default>

```go
succeed, err : = e.UpdateGroupingPolicy("g1",[]string{"data3_admin", "data4_admin"}, []string{"admin", "data4_admin"})
```

</TabItem>

<TabItem value="Java" label="Java">

```Java
boolean succeed = e.updateNamedGroupingPolicy("g1", Arrays.asList("data3_admin", "data4_admin"), Arrays.asList("admin", "data4_admin"));
```

</TabItem>

</Tabs>
