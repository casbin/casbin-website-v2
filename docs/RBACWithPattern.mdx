---
id: rbac-with-pattern
title: RBAC with Pattern
description: RBAC with Pattern
keywords: [RBAC with pattern, pattern matching]
authors: [hsluoyz]
---

## Quick Start

- Use a pattern in `g(_, _)`:

  ```go
  e, _ := NewEnforcer("./example.conf", "./example.csv")
  e.AddNamedMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
  ```

- Use a pattern with a domain:

  ```go
  e.AddNamedDomainMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
  ```

- Use all patterns:

  Combine both APIs as needed.

After creating the `enforcer` instance, activate pattern matching using the `AddNamedMatchingFunc` and `AddNamedDomainMatchingFunc` APIs, which determine how the pattern matches.

:::note
If you use the online editor, you can add a pattern matching function by clicking the "Add Role Matching" button in the lower left corner.
![editor-tips](/img/editor-tips.png)
:::

## Pattern Matching in RBAC

Sometimes, you want certain subjects, objects, or domains/tenants with a specific pattern to be automatically granted a role. Pattern matching functions in RBAC help you achieve this. A pattern matching function shares the same parameters and return value as a [matcher function](/docs/syntax-for-models#functions-in-matchers).

The pattern matching function supports each parameter of `g`.

Normally, RBAC is expressed as `g(r.sub, p.sub)` in a matcher. You can use a policy like:

```csv
p, alice, book_group, read
g, /book/1, book_group
g, /book/2, book_group
```

So `alice` can read all books including `book 1` and `book 2`. However, there can be thousands of books, and it's tedious to add each book to the book role (or group) with one `g` policy rule.

With pattern matching functions, you can write the policy with only one line:

```csv
g, /book/:id, book_group
```

Casbin will automatically match `/book/1` and `/book/2` to the pattern `/book/:id` for you. You only need to register the function with the enforcer as follows:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
e.AddNamedMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
await e.addNamedMatchingFunc('g', Util.keyMatch2Func);
```

```mdx-code-block
</TabItem>
</Tabs>
```

When using a pattern matching function in domains/tenants, register the function with the enforcer and model:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
e.AddNamedDomainMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
await e.addNamedDomainMatchingFunc('g', Util.keyMatch2Func);
```

```mdx-code-block
</TabItem>
</Tabs>
```

If you don't understand what `g(r.sub, p.sub, r.dom)` means, please read [rbac-with-domains](/docs/rbac-with-domains). In short, `g(r.sub, p.sub, r.dom)` checks whether the user `r.sub` has the role `p.sub` in the domain `r.dom`. See the full example [here](https://github.com/casbin/casbin/blob/dbdb6cbe2e7a80863e4951f9ff36da07fef01b75/model_test.go#L278-L307).

Besides the pattern matching syntax above, you can also use pure domain patterns.

For example, if you want a subject to have access in different domains, such as `domain1` and `domain2`, you can use a pure domain pattern:

```csv
p, admin, domain1, data1, read
p, admin, domain1, data1, write
p, admin, domain2, data2, read
p, admin, domain2, data2, write

g, alice, admin, *
g, bob, admin, domain2
```

In this example, `alice` can read and write `data` in both domain1 and domain2. Pattern matching with `*` in `g` gives `alice` access to both domains.

By using pattern matching, especially in complex scenarios with many domains or objects, you can implement the `policy_definition` in a more elegant and effective way.
