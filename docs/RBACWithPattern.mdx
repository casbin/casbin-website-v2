---
id: rbac-with-pattern
title: RBAC with Pattern
description: RBAC with Pattern
keywords: [RBAC with pattern, pattern matching]
authors: [hsluoyz]
---

## Quick Start

- Use pattern matching in `g(_, _)`:

  ```go
  e, _ := NewEnforcer("./example.conf", "./example.csv")
  e.AddNamedMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
  ```

- Use pattern matching with domains:

  ```go
  e.AddNamedDomainMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
  ```

- Use both patterns together:

  Simply combine both API calls.

After creating the `enforcer` instance, activate pattern matching using the `AddNamedMatchingFunc` and `AddNamedDomainMatchingFunc` APIs. These determine how the pattern matching is performed.

:::note

If using the online editor, add a pattern matching function by clicking the "Add Role Matching" button in the lower left corner.
![editor-tips](/img/editor-tips.png)

:::

## Use pattern matching in RBAC

Sometimes you want subjects, objects, or domains with a specific pattern to automatically inherit a role. Pattern matching functions in RBAC enable this behavior. These functions share the same parameters and return values as the [matcher functions](/docs/syntax-for-models#functions-in-matchers).

Pattern matching functions work with each parameter of `g`.

Normally, RBAC is expressed as `g(r.sub, p.sub)` in a matcher. You can then use policies like:

```csv
p, alice, book_group, read
g, /book/1, book_group
g, /book/2, book_group
```

In this case, `alice` can read all books, including `book 1` and `book 2`. However, with thousands of books, adding each one individually to the book role or group with a separate `g` policy becomes tedious.

With pattern matching functions, you can write the policy in a single line:

```csv
g, /book/:id, book_group
```

Casbin automatically matches `/book/1` and `/book/2` to the pattern `/book/:id`. You just need to register the function with the enforcer:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
e.AddNamedMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
await e.addNamedMatchingFunc('g', Util.keyMatch2Func);
```

```mdx-code-block
</TabItem>
</Tabs>
```

When using pattern matching with domains, register the function with both the enforcer and the model:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
e.AddNamedDomainMatchingFunc("g", "KeyMatch2", util.KeyMatch2)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
await e.addNamedDomainMatchingFunc('g', Util.keyMatch2Func);
```

```mdx-code-block
</TabItem>
</Tabs>
```

If you're unclear about the meaning of `g(r.sub, p.sub, r.dom)`, refer to [rbac-with-domains](/docs/rbac-with-domains). In brief, `g(r.sub, p.sub, r.dom)` checks whether user `r.sub` has role `p.sub` in domain `r.dom`. For a complete example, see [here](https://github.com/casbin/casbin/blob/dbdb6cbe2e7a80863e4951f9ff36da07fef01b75/model_test.go#L278-L307).

:::note

Pattern matching with domains supports custom domain token names. Instead of `dom`, you can use any identifier like `tenant` or `workspace`. Casbin automatically detects the domain token name from your model definition when using pattern matching functions like `keyMatch`.

:::

You can also use pure domain patterns in addition to the pattern matching syntax shown above.

For example, to grant `sub` access across different domains like `domain1` and `domain2`, use pure domain patterns:

```csv
p, admin, domain1, data1, read
p, admin, domain1, data1, write
p, admin, domain2, data2, read
p, admin, domain2, data2, write

g, alice, admin, *
g, bob, admin, domain2
```

Here, `alice` can read and write `data` in both `domain1` and `domain2`. The wildcard `*` in `g` grants `alice` access across both domains.

Pattern matching is particularly useful in complex scenarios with many domains or objects, enabling more elegant and effective `policy_definition` implementations.
