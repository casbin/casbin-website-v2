---
id: get-started
title: Get Started
description: Step-by-step guide to installing and using Casbin
keywords: [Casbin, get started, installation, usage]
authors: [nodece]
---

## Installation

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```bash
go get github.com/casbin/casbin/v2
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

For Maven:

```xml
<!-- https://mvnrepository.com/artifact/org.casbin/jcasbin -->
<dependency>
    <groupId>org.casbin</groupId>
    <artifactId>jcasbin</artifactId>
    <version>1.x.y</version>
</dependency>
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```bash
# NPM
npm install casbin --save

# Yarn
yarn add casbin
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

Add this package to your project's `composer.json` to download the package:

```bash
composer require casbin/casbin
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```bash
pip install casbin
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```bash
dotnet add package Casbin.NET
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```bash
# Download source
git clone https://github.com/casbin/casbin-cpp.git

# Generate project files
cd casbin-cpp && mkdir build && cd build && cmake .. -DCMAKE_BUILD_TYPE=Release

# Build and install casbin
cmake --build . --config Release --target casbin install -j 10
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```bash
cargo install cargo-edit
cargo add casbin

// If using async-std as your async executor
cargo add async-std

// If using tokio as your async executor, activate its `macros` feature
cargo add tokio
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

Casbin4D is available as a package (currently for Delphi 10.3 Rio) and can be installed in the IDE. However, there are no visual components, which means you can use the units independently of packages. Simply import the units in your project (assuming you do not mind the number of them).

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```bash
luarocks install casbin  
```

If you receive an error message: "Your user does not have write permissions in /usr/local/lib/luarocks/rocks", you may want to run the command as a privileged user or use your local tree with `--local`. To fix the error, you can add `--local` to your command like this:

```bash
luarocks install casbin --local
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Create a Casbin Enforcer

Casbin requires two core configuration files to define the access control system:
- `model.conf`: Defines the access control model structure
- `policy.csv`: Stores specific user permission rules

The typical Casbin workflow is to initialize an **Enforcer** instance with these two configuration files. Technically, an Enforcer requires two components: a [Model](supported-models) definition (access control structure) and an [Adapter](adapters) (policy storage mechanism).

Casbin provides a built-in [FileAdapter](adapters#built-in-file-adapter-example) for basic file-based policy storage. Refer to the [Adapter documentation](adapters) for additional storage options.

### Example: Initialize an Enforcer with a model file and the default [FileAdapter](adapters#built-in-file-adapter-example) for policy storage:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
import "github.com/casbin/casbin/v2"

e, err := casbin.NewEnforcer("path/to/model.conf", "path/to/policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
import org.casbin.jcasbin.main.Enforcer;

Enforcer e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```javascript
import { newEnforcer } from 'casbin';

const e = await newEnforcer('path/to/model.conf', 'path/to/policy.csv');
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
require_once './vendor/autoload.php';

use Casbin\Enforcer;

$e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
import casbin

e = casbin.Enforcer("path/to/model.conf", "path/to/policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
using NetCasbin; 

var e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```cpp
#include <iostream>
#include <casbin/casbin.h>

int main() {
    // Create an Enforcer
    casbin::Enforcer e("path/to/model.conf", "path/to/policy.csv");

    // Your authorization logic here..
}
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
var
  casbin: ICasbin;
begin
  casbin := TCasbin.Create('path/to/model.conf', 'path/to/policy.csv');
  ...
end
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
use casbin::prelude::*;

// If you use async-std as async executor
#[cfg(feature = "runtime-async-std")]
#[async_std::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}

// If you use tokio as async executor
#[cfg(feature = "runtime-tokio")]
#[tokio::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
local Enforcer = require("casbin")
local e = Enforcer:new("path/to/model.conf", "path/to/policy.csv") -- The Casbin Enforcer
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Use the Model text with other Adapters:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
import (
    "log"

    "github.com/casbin/casbin/v2"
    "github.com/casbin/casbin/v2/model"
    xormadapter "github.com/casbin/xorm-adapter/v2"
    _ "github.com/go-sql-driver/mysql"
)

// Initialize a Xorm adapter with MySQL database.
a, err := xormadapter.NewAdapter("mysql", "mysql_username:mysql_password@tcp(127.0.0.1:3306)/")
if err != nil {
    log.Fatalf("error: adapter: %s", err)
}

m, err := model.NewModelFromString(`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
`)
if err != nil {
    log.Fatalf("error: model: %s", err)
}

e, err := casbin.NewEnforcer(m, a)
if err != nil {
    log.Fatalf("error: enforcer: %s", err)
}
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
import casbin
import casbin_sqlalchemy_adapter


# Use SQLAlchemy Casbin adapter with SQLite DB
adapter = casbin_sqlalchemy_adapter.Adapter('sqlite:///test.db')

# Create a config model policy
with open("rbac_example_model.conf", "w") as f:
    f.write("""
    [request_definition]
    r = sub, obj, act

    [policy_definition]
    p = sub, obj, act

    [policy_effect]
    e = some(where (p.eft == allow))

    [matchers]
    m = r.sub == p.sub && r.obj == p.obj && r.act == p.act
    """)

# Create enforcer from adapter and config policy
e = casbin.Enforcer('rbac_example_model.conf', adapter)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Check Permissions

Add an enforcement hook into your code right before the access happens:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
sub := "alice" // the user that wants to access a resource.
obj := "data1" // the resource that is going to be accessed.
act := "read" // the operation that the user performs on the resource.

ok, err := e.Enforce(sub, obj, act)

if err != nil {
    // handle err
}

if ok == true {
    // permit alice to read data1
} else {
    // deny the request, show an error
}

// You could use BatchEnforce() to enforce some requests in batches.
// This method returns a bool slice, and this slice's index corresponds to the row index of the two-dimensional array.
// Example:
// requests = [["alice", "data1", "read"], ["bob", "data2", "write"]]
// results = e.BatchEnforce(requests)
// results[0] will be the enforcement result for the first request
results, err := e.BatchEnforce([][]interface{}{{"alice", "data1", "read"}, {"bob", "data2", "write"}, {"jack", "data3", "read"}})
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String sub = "alice"; // the user that wants to access a resource.
String obj = "data1"; // the resource that is going to be accessed.
String act = "read"; // the operation that the user performs on the resource.

if (e.enforce(sub, obj, act) == true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```js
const sub = 'alice'; // the user that wants to access a resource.
const obj = 'data1'; // the resource that is going to be accessed.
const act = 'read'; // the operation that the user performs on the resource.

if ((await e.enforce(sub, obj, act)) === true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$sub = "alice"; // the user that wants to access a resource.
$obj = "data1"; // the resource that is going to be accessed.
$act = "read"; // the operation that the user performs on the resource.

if ($e->enforce($sub, $obj, $act) === true) {
    // permit alice to read data1
} else {
    // deny the request, show an error
}
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
sub = "alice"  # the user that wants to access a resource.
obj = "data1"  # the resource that is going to be accessed.
act = "read"  # the operation that the user performs on the resource.

if e.enforce(sub, obj, act):
    # permit alice to read data1
    pass
else:
    # deny the request, show an error
    pass
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var sub = "alice";  // the user that wants to access a resource.
var obj = "data1";  // the resource that is going to be accessed.
var act = "read";  // the operation that the user performs on the resource.

if (await e.EnforceAsync(sub, obj, act)) 
{
    // permit alice to read data1
}
else
{
    // deny the request, show an error
}
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```cpp
    casbin::Enforcer e("../assets/model.conf", "../assets/policy.csv");

    if (e.Enforce({"alice", "/alice_data/hello", "GET"})) {
        std::cout << "Enforce OK" << std::endl;
    } else {
        std::cout << "Access denied" << std::endl;
    }

    if (e.Enforce({"alice", "/alice_data/hello", "POST"})) {
        std::cout << "Enforce OK" << std::endl;
    } else {
        std::cout << "Access denied" << std::endl;
    }
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
if casbin.enforce(['alice', 'data1', 'read']) then
  // permit alice to read data1
else
  // deny the request, show an error
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
  let sub = "alice"; // the user that wants to access a resource.
  let obj = "data1"; // the resource that is going to be accessed.
  let act = "read"; // the operation that the user performs on the resource.

  if e.enforce((sub, obj, act)).await? {
      // permit alice to read data1
  } else {
      // deny the request, show an error
  }
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
if e:enforce("alice", "data1", "read") then
   -- permit alice to read data1
else
   -- deny the request, show an error
end

```

```mdx-code-block
</TabItem>
</Tabs>
```

Casbin also provides APIs for permission management at runtime. For example, you can retrieve all roles assigned to a user as shown below:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
roles, err := e.GetRolesForUser("alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> roles = e.getRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```javascript
const roles = await e.getRolesForUser('alice');
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$roles = $e->getRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
roles = e.get_roles_for_user("alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var roles = e.GetRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
roles = e.rolesForEntity("alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let roles = e.get_roles_for_user("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
local roles = e:GetRolesForUser("alice")
```

```mdx-code-block
</TabItem>
</Tabs>
```

See [Management API](/docs/management-api) and [RBAC API](/docs/rbac-api) for more usage.

Please refer to the test cases for more usage.
