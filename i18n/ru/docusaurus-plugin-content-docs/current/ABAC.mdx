---
id: abac
title: АДАТ
description: ABAC based on Casbin
keywords:
  - ABAC
  - ABAC model
authors:
  - hsluoyz
---

## Что такое модель ABAC?

ABAC это `контроль доступа на основе атрибутов`, что означает, что вы можете использовать атрибуты (свойства) предмета, объект или действие вместо себя (строка) для контроля доступа. Вы можете уже слышать о сложном языке контроля доступа ABAC под названием XACML. По сравнению с XACML, ABAC Касбину очень прост: в ABAC, можно использовать структуры (или экземпляры класса, основанные на языке программирования) вместо строки для элементов модели.

Используйте официальный пример ABAC например:

```ini
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = r.sub == r.obj.Owner
```

Мы используем `r.obj.Owner` вместо `r.obj` в матче. Передача `r.obj` функции `Enforce()` будет структурой или экземпляром класса вместо строки. Касбин использует отражение, чтобы получить переменную `obj` члена в этой структуре или классе.

Вот определение для `r.obj` структуры или класса:

```go
type testResource struct {
    Name  string
    Owner string
}
```

## Как использовать ABAC?

Просто говорите, чтобы использовать ABAC, вам нужно выполнить две вещи:

1. Укажите атрибуты в модельном матче.
2. Передать в структуру или экземпляр класса элемента в качестве аргумента функции `Enforce()`.

:::warning

В настоящее время только запрашивать элементы типа `r.sub`, `r.obj`, `r.act` и так далее поддерживать ABAC. Вы не можете использовать его на элементах политики, таких как `. ub`, потому что нет способа определить структуру или класс в политике Casbin.

:::

:::tip

В матче можно использовать несколько атрибутов АВА, например: `m = r.sub.Domain == r.obj.Domain`.

:::

:::tip

Если вам нужно использовать запятую в политике, которая конфликтует с разделителем csv и нам нужно избежать этого. Касбин анализирует файл политики через [csv библиотеку](https://pkg.go.dev/encoding/csv), вы можете округлить оператор кавычками. Например, `"keyMatch("bob", r.sub.Role)"` не будет разделен.

:::

## Масштабирование модели для сложного и большого количества правил ABAC.

Вышеприведенный пример реализации АВК является очень простым, но часто система авторизации нуждается в очень сложном и большом количестве правил ABAC. С учетом этой необходимости вышеупомянутая реализация в значительной степени повысит точность модели. Поэтому целесообразно добавлять правила в политику вместо того, чтобы в модель. Это делается путем введения функциональной конструкции `eval()`. Ниже приведен пример управления такими моделями АВС.

Это определение файла `CONF` , используемого для определения модели ABAC.

```ini
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub_rule, obj, act

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = eval(p.sub_rule) && r.obj == p.obj && r.act == p.act
```

Здесь `p.sub_rule` имеет тип структуры или класса (пользовательский тип), который состоит из необходимых атрибутов, которые будут использоваться в политике.

Это политика, которая используется против модели `Принудительная`. Теперь вы можете использовать экземпляр объекта, который передается `eval()` в качестве параметра для определения ограничений ABAC.

```csv
p, r.sub.Age > 18, /data1, read
p, r.sub.Age < 60, /data2, write
```
