---
id: how-it-works
title: Как это работает
description: How Casbin works
keywords:
  - PERM
  - request
  - policy
  - matcher
  - effect
authors:
  - nodece
---

В Касбине модель контроля доступа абстрагируется в CONF файл, основанный на **метамоделе PERM (политика, эффект, запрос, Matchers)**. Таким образом, переключение или обновление механизма авторизации для проекта так же просто, как и изменение конфигурации. Вы можете настроить свою собственную модель контроля доступа, комбинируя доступные модели. Например, вы можете комбинировать роли RBAC и атрибуты ABAC внутри одной модели и поделиться одним набором правил политики.

Модель PERM состоит из четырех основ (политика, действие, запрос, Matchers), описывающих взаимоотношения между ресурсами и пользователями.

### Запросить
Определите параметры запроса. Основной запрос - это туфельный объект, требующий, по крайней мере, предмет (доступная сущность), объект (доступный ресурс) и действие (метод доступа)

Например, определение запроса может выглядеть следующим образом: `r={sub,obj,act}`

На самом деле он определяет имя параметра и его порядок, который мы должны предоставить для функции контроля доступа.

### Политика
Определите модель стратегии доступа. На самом деле она определяет название и порядок полей в документе Правило Политики.

Например: `p={sub, obj, act}` или `p={sub, obj, act, eft}`

Примечание: Если eft (результат политики) не определен, то поле результата в файле политики не будет прочитано, и результаты соответствующей политики будут разрешены по умолчанию.

### Матчер
Соответствующие правила запроса и политики.

Пример: `m = r.sub == p.sub && r.act == p.act && r.obj == p. bj` Это простое и общее совпадающее правило означает, что если запрашиваемые параметры (сущности, и методы) равны, то есть если их можно найти в политике, то результат политики (`p. f`) возвращается. Результат стратегии будет сохранен в `p.eft`.

### Эффект
Это можно понимать как модель, в которой логическая комбинация вновь выполняется по результатам совпадений матчей.

Например: `e = некоторый (where(p.eft == разрешить))`

Это предложение означает, что если результат совпадения p.eft имеет (некоторый) результат, то окончательный результат верно

Давайте посмотрим на другой пример: `e = где-то (где (p.eft == allow)) && !some(где (p. ft == отрицать))` Логическое значение этой комбинации примеров: если существует стратегия, которая соответствует результату разрешения и не соответствует результату отрицания, результат верен. Другими словами, верно, когда все совпадающие стратегии разрешены, если есть отрицание, оба являются ложными (более просто, когда позволяют и отрицают существование в то же время, отрицание имеет приоритет)

Самая простая и простая модель в Касбине это ACL. Модель ACL CONF:

```ini
# Определение запроса
[request_definition]
r = sub, obj, act

# Определение политики
[policy_definition]
p = sub, obj, act

# Эффект политики
[policy_effect]
e = как-то (стр. ft == позволять))

# Матчей
[matchers]
м = r. ub == p.sub && r.obj == p.obj && r.act == p.act

```

Пример политики для модели ACL аналогичен:

```
p, alice, data1, чтение
p, bob, data2, запись
```

Это означает:

- alice может читать данные1
- Боб может записать данные2

Мы также поддерживаем многострочный режим, добавив '\\' в конце:

```ini
# Соответствия
[matchers]
m = r.sub == p.sub && r.obj == p.obj \ 
  && r.act == p.act
```

Более того, если вы используете ABAC, вы можете попробовать оператора `в` , как указано в редакции Casbin **golang** (jCasbin и Node-Casbin пока не поддерживаются):

```ini
# Соответствия
[matchers]
м = r.obj == p.obj && r.act == p.act || r.obj в ('data2', 'data3')
```

Но вы **ДОЛЖНЫ** убедитесь в том, что длина массива **БОЛЬШЕ** чем **1**, в противном случае это вызовет панику.

Для большего количества операторов вы можете взглянуть на [govaluate](https://github.com/Knetic/govaluate)

