---
id: management-api
title: Management-API
description: The primitive API that provides full support for Casbin policy management
keywords:
  - management
  - Filtered API
authors:
  - nodece
---



Die primitive API, die volle Unterstützung für das Management der Casbin-Richtlinien bietet.

## Gefilterte API

Fast alle gefilterten api haben die gleichen Parameter `(fieldIndex int, fieldValues ...string)`. `fieldIndex` ist der Index, in dem der übereinstimmende Anfang, `fieldValues` bezeichnet das Ergebnis, das Werte haben sollen. Beachten Sie, dass ein leerer String in Feldwerten ein beliebiges Wort sein kann.

Beispiel:

```csv
p, alice, book, read
p, bob, book, read
p, bob, book, write
p, alice, pen, get
p, bob, pen ,get
```

```go
e.GetFilteredPolicy(1, "Buch") // wird zurückgegeben: [[Alice Book read] [Bob Book read] [Bob Book write]]

e. etFilteredPolicy(1, "book", "read") // gibt zurück: [[alice book read] [bob book read]]

e. etFilteredPolicy(0, "alice", "", "read") // wird zurückgegeben: [[alice book read]]

e.GetFilteredPolicy(0, "alice") // wird zurückgeben: [[alice book read] [alice pen get]]
```

## Referenz

globale Variable `e` ist Enforcer Instanz.

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
e, err := NewEnforcer("examples/rbac_model.conf", "examples/rbac_policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const e = await newEnforcer('examples/rbac_model.conf', 'examples/rbac_policy.csv')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$e = new Enforcer('examples/rbac_model.conf', 'examples/rbac_policy.csv');
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
e = casbin.Enforcer("examples/rbac_model.conf", "examples/rbac_policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let mut e = Enforce::new("examples/rbac_model.conf", "examples/rbac_policy.csv").await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
Enforcer e = new Enforcer("examples/rbac_model.conf", "examples/rbac_policy.csv");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `Enforce()`

Enforce entscheidet, ob ein "Betreff" mit der Operation "action" auf ein "Objekt" zugreifen kann, die Eingabeparameter sind üblich: (sub, obj, act).

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.Enforce(request)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const ok = await e.enforce(request);
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$ok = $e->enforcer($request);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
ok = e.enforcer(request)
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean ok = e.enforce(request);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `EnforceWithMatcher()`

EnforceWithMatcher verwendet einen benutzerdefinierten Matcher um zu entscheiden, ob ein "Betreff" mit der Operation "Aktion" auf ein "Objekt" zugreifen kann Eingabeparameter sind üblich: (Matcher, Sub, obj, act), verwenden Sie standardmäßig Modellmatcher wenn der Matcher "" ist.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.EnforceWithMatcher(matcher, request)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$ok = $e->enforceWithMatcher($matcher, $request);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
ok = e.enforce_with_matcher(matcher, request)
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean ok = e.enforceWithMatcher(matcher, request);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `EnforceEx()`

EnforceEx erklärt die Durchsetzung durch entsprechende Regeln.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, reason, err := e.EnforceEx(request)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const ok = await e.enforceEx(request);
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
list($ok, $reason) = $e->enforceEx($request);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
ok, reason = e.enforce_ex(request)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `EnforceExWithMatcher()`

EnforceExWithMatcher verwenden einen benutzerdefinierten Matcher und erläutern die Durchsetzung durch Informationen über die entsprechenden Regeln.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, reason, err := e.EnforceExWithMatcher(matcher, request)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `BatchEnforce()`

BatchErzwinge jede Anfrage und gibt Ergebnis in einem Bool-Array zurück

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
boolArray, err := e.BatchEnforce(requests)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const boolArray = await e.batchEnforce(requests);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<Boolean> boolArray = e.batchEnforce(requests);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllSubjects()`

GetAllSubjects bekommt die Liste der Themen, die in der aktuellen Richtlinie erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allSubjects := e.GetAllSubjects()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allSubjects = await e.getAllSubjects()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allSubjects = $e->getAllSubjects();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_subjects = e.get_all_subjects()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allSubjects = e.GetAllSubjects();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_subjects = e.get_all_subjects();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allSubjects = e.getAllSubjects();
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllNamedSubjects()`

GetAllNamedSubjects erhält die Liste der Themen, die in der aktuell benannten Richtlinie erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allNamedSubjects := e.GetAllNamedSubjects("p")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allNamedSubjects = await e.getAllNamedSubjects('p')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allNamedSubjects = $e->getAllNamedSubjects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_named_subjects = e.get_all_named_subjects("p")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allNamedSubjects = e.GetAllNamedSubjects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_named_subjects = e.get_all_named_subjects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allNamedSubjects = e.getAllNamedSubjects("p");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllObjects()`

GetAllObjects erhält die Liste der Objekte, die in der aktuellen Richtlinie erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allObjects := e.GetAllObjects()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allObjects = await e.getAllObjects()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allObjects = $e->getAllObjects();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_objects = e.get_all_objects()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allObjects = e.GetAllObjects();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_objects = e.get_all_objects();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allObjects = e.getAllObjects();
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllNamedObjects()`

GetAllNamedObjects erhält die Liste der Objekte, die in den aktuell benannten Richtlinien erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allNamedObjects := e.GetAllNamedObjects("p")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allNamedObjects = await e.getAllNamedObjects('p')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allNamedObjects = $e->getAllNamedObjects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_named_objects = e.get_all_named_objects("p")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allNamedObjects = e.GetAllNamedObjects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_named_objects = e.get_all_named_objects("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allNamedObjects = e.getAllNamedObjects("p");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllActions()`

GetAllActions erhält die Liste der Aktionen, die in der aktuellen Richtlinie erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allActions := e.GetAllActions()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allActions = await e.getAllActions()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allActions = $e->getAllActions();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_actions = e.get_all_actions()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allActions = e.GetAllActions();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_actions = e.get_all_actions();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allActions = e.getAllActions();
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllNamedActions()`

GetAllNamedActions erhält die Liste der Aktionen, die in den aktuell benannten Richtlinien erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allNamedActions := e.GetAllNamedActions("p")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allNamedActions = await e.getAllNamedActions('p')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allNamedActions = $e->getAllNamedActions("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_named_actions = e.get_all_named_actions("p")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allNamedActions = e.GetAllNamedActions("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_named_actions = e.get_all_named_actions("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allNamedActions = e.getAllNamedActions("p");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllRoles()`

GetAllRoles erhält die Liste der Rollen, die in den aktuellen Richtlinien erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```
allRoles = e.GetAllRoles()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allRoles = await e.getAllRoles()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allRoles = $e->getAllRoles();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_roles = e.get_all_roles()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allRoles = e.GetAllRoles();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_roles = e.get_all_roles();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allRoles = e.getAllRoles();
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetAllNamedRoles()`

GetAllNamedRoles erhält die Liste der Rollen, die in den aktuell benannten Richtlinien erscheinen.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
allNamedRoles := e.GetAllNamedRoles("g")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const allNamedRoles = await e.getAllNamedRoles('g')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$allNamedRoles = $e->getAllNamedRoles('g');
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
all_named_roles = e.get_all_named_roles("g")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var allNamedRoles = e.GetAllNamedRoles("g");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let all_named_roles = e.get_all_named_roles("g");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> allNamedRoles = e.getAllNamedRoles("g");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetPolicy()`

GetPolicy erhält alle Autorisierungsregeln in der Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
policy = e.GetPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const policy = await e.getPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$policy = $e->getPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
policy = e.get_policy()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var policy = e.GetPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let policy = e.get_policy();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> policy = e.getPolicy();
```

```mdx-code-block
</TabItem>
</Tabs>
```


### `GetFilteredPolicy()`

GetFilteredPolicy holt alle Autorisierungsregeln in der Richtlinie, Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
filteredPolicy := e.GetFilteredPolicy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const filteredPolicy = await e.getFilteredPolicy(0, 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$filteredPolicy = $e->getFilteredPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
filtered_policy = e.get_filtered_policy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var filteredPolicy = e.GetFilteredPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let filtered_policy = e.get_filtered_policy(0, vec!["alice".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> filteredPolicy = e.getFilteredPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetNamedPolicy()`

GetNamedPolicy holt alle Autorisierungsregeln in den genannten Richtlinien.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
namedPolicy := e.GetNamedPolicy("p")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const namedPolicy = await e.getNamedPolicy('p')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$namedPolicy = $e->getNamedPolicy("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
named_policy = e.get_named_policy("p")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var namedPolicy = e.GetNamedPolicy("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let named_policy = e.get_named_policy("p");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> namedPolicy = e.getNamedPolicy("p");
```

```mdx-code-block
</TabItem>
</Tabs>
```


### `GetFilteredNamedPolicy()`

GetFilteredNamedPolicy holt alle Autorisierungsregeln in den angegebenen Richtlinien, Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
filteredNamedPolicy = e.GetFilteredNamedPolicy("p", 0, "bob")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const filteredNamedPolicy = await e.getFilteredNamedPolicy('p', 0, 'bob')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$filteredNamedPolicy = $e->getFilteredNamedPolicy("p", 0, "bob");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
filtered_named_policy = e.get_filtered_named_policy("p", 0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var filteredNamedPolicy = e.GetFilteredNamedPolicy("p", 0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let filtered_named_policy = e.get_filtered_named_policy("p", 0, vec!["bob".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> filteredNamedPolicy = e.getFilteredNamedPolicy("p", 0, "bob");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetGroupingPolicy()`

GetGroupingPolicy erhält alle Rollenvererbung Regeln in der Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
groupingPolicy := e.GetGroupingPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const groupingPolicy = await e.getGroupingPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$groupingPolicy = $e->getGroupingPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
grouping_policy = e.get_grouping_policy()
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var groupingPolicy = e.GetGroupingPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let grouping_policy = e.get_grouping_policy();
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> groupingPolicy = e.getGroupingPolicy();
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetFilteredGroupingPolicy()`

GetFilteredGroupingPolicy erhält alle Rollenvererbungsregeln in der Richtlinie, Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
filteredGroupingPolicy := e.GetFilteredGroupingPolicy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const filteredGroupingPolicy = await e.getFilteredGroupingPolicy(0, 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$filteredGroupingPolicy = $e->getFilteredGroupingPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
filtered_grouping_policy = e.get_filtered_grouping_policy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var filteredGroupingPolicy = e.GetFilteredGroupingPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let filtered_grouping_policy = e.get_filtered_grouping_policy(0, vec!["alice".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> filteredGroupingPolicy = e.getFilteredGroupingPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetNamedGroupingPolicy()`

GetNamedGroupingPolicy erhält alle Rollenvererbungsregeln in der Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
namedGroupingPolicy := e.GetNamedGroupingPolicy("g")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const namedGroupingPolicy = await e.getNamedGroupingPolicy('g')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$namedGroupingPolicy = $e->getNamedGroupingPolicy("g");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
named_grouping_policy = e.get_named_grouping_policy("g")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var namedGroupingPolicy = e.GetNamedGroupingPolicy("g");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let named_grouping_policy = e.get_named_grouping_policy("g");
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> namedGroupingPolicy = e.getNamedGroupingPolicy("g");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `GetFilteredNamedGroupingPolicy()`

GetFilteredNamedGroupingPolicy holt alle Rollenvererbungsregeln in der Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
namedGroupingPolicy := e.GetFilteredNamedGroupingPolicy("g", 0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const namedGroupingPolicy = await e.getFilteredNamedGroupingPolicy('g', 0, 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$namedGroupingPolicy = $e->getFilteredNamedGroupingPolicy("g", 0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
named_grouping_policy = e.get_filtered_named_grouping_policy("g", 0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var namedGroupingPolicy = e.GetFilteredNamedGroupingPolicy("g", 0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let named_grouping_policy = e.get_filtered_named_groupingPolicy("g", 0, vec!["alice".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> filteredNamedGroupingPolicy = e.getFilteredNamedGroupingPolicy("g", 0, "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `HasPolicy()`

HasPolicy bestimmt, ob eine Autorisierungsregel existiert.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
hasPolicy := e.HasPolicy("data2_admin", "data2", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const hasPolicy = await e.hasPolicy('data2_admin', 'data2', 'read')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$hasPolicy = $e->hasPolicy('data2_admin', 'data2', 'read');
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
has_policy = e.has_policy("data2_admin", "data2", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var hasPolicy = e.HasPolicy("data2_admin", "data2", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let has_policy = e.has_policy(vec!["data2_admin".to_owned(), "data2".to_owned(), "read".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean hasPolicy = e.hasPolicy("data2_admin", "data2", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `HasNamedPolicy()`

HasNamedPolicy bestimmt, ob eine benannte Autorisierungsregel existiert.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
hasNamedPolicy := e.HasNamedPolicy("p", "data2_admin", "data2", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const hasNamedPolicy = await e.hasNamedPolicy('p', 'data2_admin', 'data2', 'read')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$hasNamedPolicy = $e->hasNamedPolicy("p", "data2_admin", "data2", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
has_named_policy = e.has_named_policy("p", "data2_admin", "data2", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var hasNamedPolicy = e.HasNamedPolicy("p", "data2_admin", "data2", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let has_named_policy = e.has_named_policy("p", vec!["data2_admin".to_owned(), "data2".to_owned(), "read".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean hasNamedPolicy = e.hasNamedPolicy("p", "data2_admin", "data2", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddPolicy()`

AddPolicy fügt der aktuellen Richtlinie eine Autorisierungsregel hinzu. Wenn die Regel bereits existiert, gibt die Funktion falsch zurück und die Regel wird nicht hinzugefügt. Andernfalls gibt die Funktion true zurück, indem die neue Regel hinzugefügt wird.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
added := e.AddPolicy('eve', 'data3', 'read')
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['eve', 'data3', 'read']
const added = await e.addPolicy(...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$added = $e->addPolicy('eve', 'data3', 'read');
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
added = e.add_policy("eve", "data3", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var added = e.AddPolicy("eve", "data3", "read");
or
var added = await e.AddPolicyAsync("eve", "data3", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let added = e.add_policy(vec!["eve".to_owned(), "data3".to_owned(), "read".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean added = e.addPolicy("eve", "data3", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddPolicies()`

AddPolicies fügt Autorisierungsregeln zu den aktuellen Richtlinien hinzu. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel zur aktuellen Richtlinie hinzugefügt wird. Wenn alle Autorisierungsregeln mit den Regeln der Politik übereinstimmen, gibt die Funktion wahr zurück und jede Richtlinien-Regel wird der aktuellen Richtlinie hinzugefügt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"jack", "data4", "read"},
    []string {"katy", "data4", "write"},
    []string {"leyo", "data4", "read"},
    []string {"ham", "data4", "write"},
}

areRulesAdded := e.AddPolicies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesAdded = await e.addPolicies(rules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_added = e.add_policies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
    vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_added = e.add_policies(rules).await?
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] rules = {
    {"jack", "data4", "read"},
    {"katy", "data4", "write"},
    {"leyo", "data4", "read"},
    {"ham", "data4", "write"},
};

boolean areRulesAdded = e.addPolicies(rules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddPoliciesEx()`

AddPoliciesEx adds authorization rules to the current policy. If the rule already exists, the rule will not be added. But unlike AddPolicies, other non-existent rules are added instead of returning false directly

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.AddPoliciesEx([][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddNamedPolicy()`

AddNamedPolicy fügt der aktuell benannten Richtlinie eine Autorisierungsregel hinzu. Wenn die Regel bereits existiert, gibt die Funktion falsch zurück und die Regel wird nicht hinzugefügt. Andernfalls gibt die Funktion true zurück, indem die neue Regel hinzugefügt wird.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
added := e.AddNamedPolicy("p", "eve", "data3", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['eve', 'data3', 'read']
const added = await e.addNamedPolicy('p', ...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$added = $e->addNamedPolicy("p", "eve", "data3", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
added = e.add_named_policy("p", "eve", "data3", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var added = e.AddNamedPolicy("p", "eve", "data3", "read");
or
var added = await e.AddNamedPolicyAsync("p", "eve", "data3", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let added = e.add_named_policy("p", vec!["eve".to_owned(), "data3".to_owned(), "read".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean added = e.addNamedPolicy("p", "eve", "data3", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddNamedPolicies()`

AddNamedPolicies fügt Autorisierungsregeln zu den aktuell benannten Richtlinien hinzu. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel zur aktuellen Richtlinie hinzugefügt wird. Wenn alle Autorisierungsregeln mit den Regeln der Politik übereinstimmen, gibt die Funktion wahr zurück und jede Richtlinien-Regel wird der aktuellen Richtlinie hinzugefügt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"jack", "data4", "read"},
    []string {"katy", "data4", "write"},
    []string {"leyo", "data4", "read"},
    []string {"ham", "data4", "write"},
}

areRulesAdded := e.AddNamedPolicies("p", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesAdded = await e.addNamedPolicies('p', rules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_added = e.add_named_policies("p", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
    vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_added := e.add_named_policies("p", rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> rules = Arrays.asList(
    Arrays.asList("jack", "data4", "read"),
    Arrays.asList("katy", "data4", "write"),
    Arrays.asList("leyo", "data4", "read"),
    Arrays.asList("ham", "data4", "write")
);
boolean areRulesAdded = e.addNamedPolicies("p", rules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddNamedPoliciesEx()`

AddNamedPoliciesEx adds authorization rules to the current named policy. If the rule already exists, the rule will not be added. But unlike AddNamedPolicies, other non-existent rules are added instead of returning false directly

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.AddNamedPoliciesEx("p", [][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `SelfAddPoliciesEx()`

SelfAddPoliciesEx adds authorization rules to the current named policy with autoNotifyWatcher disabled. If the rule already exists, the rule will not be added. But unlike SelfAddPolicies, other non-existent rules are added instead of returning false directly

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.SelfAddPoliciesEx("p", "p", [][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
```
```mdx-code-block
</TabItem>
</Tabs>
```

### `RemovePolicy()`

Entfernt eine Autorisierungsregel aus der aktuellen Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemovePolicy("alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removePolicy(...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removePolicy("alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_policy("alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemovePolicy("alice", "data1", "read");
or
var removed = await e.RemovePolicyAsync("alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_policy(vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removePolicy("alice", "data1", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemovePolicies()`

Entfernen von Richtlinien entfernt Autorisierungsregeln aus der aktuellen Richtlinie. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel aus der aktuellen Richtlinie entfernt wird. Wenn alle Autorisierungsregeln mit den Regeln übereinstimmen, gibt die Funktion wahr zurück und jede Regel wird aus der aktuellen Richtlinie entfernt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"jack", "data4", "read"},
    []string {"katy", "data4", "write"},
    []string {"leyo", "data4", "read"},
    []string {"ham", "data4", "write"},
}

areRulesRemoved := e.RemovePolicies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesRemoved = await e.removePolicies(rules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_removed = e.remove_policies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
    vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let are_rules_removed = e.remove_policies(rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] rules = {
    {"jack", "data4", "read"},
    {"katy", "data4", "write"},
    {"leyo", "data4", "read"},
    {"ham", "data4", "write"},
};
boolean areRulesRemoved = e.removePolicies(rules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveFilteredPolicy()`

Entfernen FilteredPolicy entfernt eine Autorisierungsregel aus der aktuellen Richtlinie. Feldfilter können angegeben werden. Entfernt eine Autorisierungsregel aus der aktuellen Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveFilteredPolicy(0, "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeFilteredPolicy(0, ...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeFilteredPolicy(0, "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_filtered_policy(0, "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveFilteredPolicy("alice", "data1", "read");
or
var removed = await e.RemoveFilteredPolicyAsync("alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_filtered_policy(0, vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeFilteredPolicy(0, "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveNamedPolicy()`

Entfernt eine Autorisierungsregel aus der aktuell benannten Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveNamedPolicy("p", "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeNamedPolicy('p', ...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeNamedPolicy("p", "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_named_policy("p", "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveNamedPolicy("p", "alice", "data1", "read");
or
var removed = await e.RemoveNamedPolicyAsync("p", "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_named_policy("p", vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeNamedPolicy("p", "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveNamedPolicies()`

Entfernt die Autorisierungsregeln aus der aktuell benannten Richtlinie. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel aus der aktuellen Richtlinie entfernt wird. Wenn alle Autorisierungsregeln mit den Regeln übereinstimmen, gibt die Funktion wahr zurück und jede Regel wird aus der aktuellen Richtlinie entfernt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"jack", "data4", "read"},
    []string {"katy", "data4", "write"},
    []string {"leyo", "data4", "read"},
    []string {"ham", "data4", "write"},
}

areRulesRemoved := e.RemoveNamedPolicies("p", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const rules = [
    ['jack', 'data4', 'read'],
    ['katy', 'data4', 'write'],
    ['leyo', 'data4', 'read'],
    ['ham', 'data4', 'write']
];

const areRulesRemoved = await e.removeNamedPolicies('p', rules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["jack", "data4", "read"],
    ["katy", "data4", "write"],
    ["leyo", "data4", "read"],
    ["ham", "data4", "write"]
]
are_rules_removed = e.remove_named_policies("p", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["jack".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["katy".to_owned(), "data4".to_owned(), "write".to_owned()],
    vec!["leyo".to_owned(), "data4".to_owned(), "read".to_owned()],
    vec!["ham".to_owned(), "data4".to_owned(), "write".to_owned()],
];

let areRulesRemoved = e.remove_named_policies("p", rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<List<String>> rules = Arrays.asList(
    Arrays.asList("jack", "data4", "read"),
    Arrays.asList("katy", "data4", "write"),
    Arrays.asList("leyo", "data4", "read"),
    Arrays.asList("ham", "data4", "write")
);
boolean areRulesRemoved = e.removeNamedPolicies("p", rules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveFilteredNamedPolicy()`

RemoveFilteredNamedPolicy entfernt eine Autorisierungsregel aus der aktuellen Richtlinie. Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveFilteredNamedPolicy("p", 0, "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const p = ['alice', 'data1', 'read']
const removed = await e.removeFilteredNamedPolicy('p', 0, ...p)
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeFilteredNamedPolicy("p", 0, "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_filtered_named_policy("p", 0, "alice", "data1", "read")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveFilteredNamedPolicy("p", 0, "alice", "data1", "read");
or
var removed = e.RemoveFilteredNamedPolicyAync("p", 0, "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_filtered_named_policy("p", 0, vec!["alice".to_owned(), "data1".to_owned(), "read".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeFilteredNamedPolicy("p", 0, "alice", "data1", "read");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `HasGroupingPolicy()`

HasGroupingPolicy bestimmt, ob eine Rollenvererbungsregel existiert.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
has := e.HasGroupingPolicy("alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const has = await e.hasGroupingPolicy('alice', 'data2_admin')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$has = $e->hasGroupingPolicy("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
has = e.has_grouping_policy("alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var has = e.HasGroupingPolicy("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let has = e.has_grouping_policy(vec!["alice".to_owned(), "data2_admin".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean has = e.hasGroupingPolicy("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `HasNamedGroupingPolicy()`

HasNamedGroupingPolicy legt fest, ob eine benannte Rollenvererbungsregel existiert.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
has := e.HasNamedGroupingPolicy("g", "alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const has = await e.hasNamedGroupingPolicy('g', 'alice', 'data2_admin')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$has = $e->hasNamedGroupingPolicy("g", "alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
has = e.has_named_grouping_policy("g", "alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var has = e.HasNamedGroupingPolicy("g", "alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let has = e.has_named_grouping_policy("g", vec!["alice".to_owned(), "data2_admin".to_owned()]);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean has = e.hasNamedGroupingPolicy("g", "alice", "data2_admin");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddGroupingPolicy()`

AddGroupingPolicy fügt der aktuellen Richtlinie eine Rollenvererbungsregel hinzu. Wenn die Regel bereits existiert, gibt die Funktion falsch zurück und die Regel wird nicht hinzugefügt. Andernfalls gibt die Funktion true zurück, indem die neue Regel hinzugefügt wird.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
added := e.AddGroupingPolicy("group1", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const added = await e.addGroupingPolicy('group1', 'data2_admin')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$added = $e->addGroupingPolicy("group1", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
added = e.add_grouping_policy("group1", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var added = e.AddGroupingPolicy("group1", "data2_admin");
or
var added = await e.AddGroupingPolicyAsync("group1", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let added = e.add_grouping_policy(vec!["group1".to_owned(), "data2_admin".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean added = e.addGroupingPolicy("group1", "data2_admin");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddGroupingPolicies()`

AddGroupingPolicies fügt Rollenvererbungsregeln zu den aktuellen Richtlinien hinzu. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel zur aktuellen Richtlinie hinzugefügt wird. Wenn alle Autorisierungen mit den Regeln übereinstimmen, gibt die Funktion wahr zurück und jede Richtlinien-Regel wird der aktuellen Richtlinie hinzugefügt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"ham", "data4_admin"},
    []string {"jack", "data5_admin"},
}

areRulesAdded := e.AddGroupingPolicies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesAdded = await e.addGroupingPolicies(groupingRules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_added = e.add_grouping_policies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["ham".to_owned(), "data4_admin".to_owned()],
    vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let areRulesAdded = e.add_grouping_policies(rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] groupingRules = {
    {"ham", "data4_admin"},
    {"jack", "data5_admin"}
};
boolean areRulesAdded = e.addGroupingPolicies(groupingRules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddGroupingPoliciesEx()`

AddGroupingPoliciesEx adds role inheritance rules to the current policy. If the rule already exists, the rule will not be added. But unlike AddGroupingPolicies, other non-existent rules are added instead of returning false directly

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.AddGroupingPoliciesEx([][]string{{"user1", "member"}, {"user2", "member"}})
```

```mdx-code-block
</TabItem>
</Tabs>
```
### `AddNamedGroupingPolicy()`

AddNamedGroupingPolicy fügt der aktuellen Richtlinie eine benannte Rollenvererbungsregel hinzu. Wenn die Regel bereits existiert, gibt die Funktion falsch zurück und die Regel wird nicht hinzugefügt. Andernfalls gibt die Funktion true zurück, indem die neue Regel hinzugefügt wird.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
added := e.AddNamedGroupingPolicy("g", "group1", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const added = await e.addNamedGroupingPolicy('g', 'group1', 'data2_admin')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$added = $e->addNamedGroupingPolicy("g", "group1", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
added = e.add_named_grouping_policy("g", "group1", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var added = e.AddNamedGroupingPolicy("g", "group1", "data2_admin");
or
var added = await e.AddNamedGroupingPolicyAsync("g", "group1", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let added = e.add_named_grouping_policy("g", vec!["group1".to_owned(), "data2_admin".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean added = e.addNamedGroupingPolicy("g", "group1", "data2_admin");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddNamedGroupingPolicies()`

AddNamedGroupingPolicies fügt den aktuellen Richtlinien benannte Vererbungsregeln hinzu. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel zur aktuellen Richtlinie hinzugefügt wird. Wenn alle Autorisierungsregeln mit den Regeln der Politik übereinstimmen, gibt die Funktion wahr zurück und jede Richtlinien-Regel wird der aktuellen Richtlinie hinzugefügt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"ham", "data4_admin"},
    []string {"jack", "data5_admin"},
}

areRulesAdded := e.AddNamedGroupingPolicies("g", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesAdded = await e.addNamedGroupingPolicies('g', groupingRules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_added = e.add_named_grouping_policies("g", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["ham".to_owned(), "data4_admin".to_owned()],
    vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_added = e.add_named_grouping_policies("g", rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] groupingRules = {
    {"ham", "data4_admin"},
    {"jack", "data5_admin"}
};
boolean areRulesAdded = e.addNamedGroupingPolicies("g", groupingRules);
```

```mdx-code-block
</TabItem>
</Tabs>
```
### `AddNamedGroupingPoliciesEx()`

AddNamedGroupingPoliciesEx adds named role inheritance rules to the current policy. If the rule already exists, the rule will not be added. But unlike AddNamedGroupingPolicies, other non-existent rules are added instead of returning false directly

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
ok, err := e.AddNamedGroupingPoliciesEx("g", [][]string{{"user1", "member"}, {"user2", "member"}})
```
```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveGroupingPolicy()`

RemoveGroupingPolicy entfernt eine Rollenvererbungsregel aus der aktuellen Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveGroupingPolicy("alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const removed = await e.removeGroupingPolicy('alice', 'data2_admin')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeGroupingPolicy("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_grouping_policy("alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveGroupingPolicy("alice", "data2_admin");
or
var removed = await e.RemoveGroupingPolicyAsync("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_grouping_policy(vec!["alice".to_owned(), "data2_admin".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeGroupingPolicy("alice", "data2_admin");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveGroupingPolicies()`

Entfernen von GroupingPolicies entfernt Rollenvererbungsregeln aus der aktuellen Richtlinie. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel aus der aktuellen Richtlinie entfernt wird. Wenn alle Autorisierungsregeln mit den Regeln übereinstimmen, gibt die Funktion wahr zurück und jede Regel wird aus der aktuellen Richtlinie entfernt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
                []string {"ham", "data4_admin"},
                []string {"jack", "data5_admin"},
        }

areRulesRemoved := e.RemoveGroupingPolicies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesRemoved = await e.removeGroupingPolicies(groupingRules);
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["ham".to_owned(), "data4_admin".to_owned()],
    vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_removed = e.remove_grouping_policies(rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]

are_rules_removed = e.remove_grouping_policies(rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] groupingRules = {
    {"ham", "data4_admin"},
    {"jack", "data5_admin"}
};
boolean areRulesRemoved = e.removeGroupingPolicies(groupingRules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveFilteredGroupingPolicy()`

RemoveFilteredGroupingPolicy entfernt eine Rollenvererbungsregel aus der aktuellen Richtlinie. Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveFilteredGroupingPolicy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const removed = await e.removeFilteredGroupingPolicy(0, 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeFilteredGroupingPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_filtered_grouping_policy(0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveFilteredGroupingPolicy(0, "alice");
or
var removed = await e.RemoveFilteredGroupingPolicyAsync(0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_filtered_grouping_policy(0, vec!["alice".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeFilteredGroupingPolicy(0, "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveNamedGroupingPolicy()`

RemoveNamedGroupingPolicy entfernt eine Rollenvererbungsregel aus der aktuell benannten Richtlinie.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveNamedGroupingPolicy("g", "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const removed = await e.removeNamedGroupingPolicy('g', 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeNamedGroupingPolicy("g", "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_named_grouping_policy("g", "alice", "data2_admin")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveNamedGroupingPolicy("g", "alice");
or 
var removed = await e.RemoveNamedGroupingPolicyAsync("g", "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_named_grouping_policy("g", vec!["alice".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeNamedGroupingPolicy("g", "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveNamedGroupingPolicies()`

RemoveNamedGroupingPolicies entfernt benannte Rollenvererbungsregeln aus der aktuellen Richtlinie. Die Operation ist atomarer Natur. Wenn also Autorisierungsregeln aus Regeln bestehen, die nicht mit der aktuellen Politik übereinstimmen die Funktion falsch zurückgibt und keine Richtlinien-Regel aus der aktuellen Richtlinie entfernt wird. Wenn alle Autorisierungsregeln mit den Regeln übereinstimmen, gibt die Funktion wahr zurück und jede Regel wird aus der aktuellen Richtlinie entfernt.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
rules := [][] string {
    []string {"ham", "data4_admin"},
    []string {"jack", "data5_admin"},
}

areRulesRemoved := e.RemoveNamedGroupingPolicies("g", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const groupingRules = [
    ['ham', 'data4_admin'],
    ['jack', 'data5_admin']
  ];

const areRulesRemoved = await e.removeNamedGroupingPolicies('g', groupingRules);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
rules = [
    ["ham", "data4_admin"],
    ["jack", "data5_admin"]
]
are_rules_removed = e.remove_named_grouping_policies("g", rules)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let rules = vec![
    vec!["ham".to_owned(), "data4_admin".to_owned()],
    vec!["jack".to_owned(), "data5_admin".to_owned()],
];

let are_rules_removed = e.remove_named_grouping_policies("g", rules).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String[][] groupingRules = {
    {"ham", "data4_admin"},
    {"jack", "data5_admin"}
};
boolean areRulesRemoved = e.removeNamedGroupingPolicies("g", groupingRules);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `RemoveFilteredNamedGroupingPolicy()`

RemoveFilteredNamedGroupingPolicy entfernt eine Rollenvererbungsregel aus der aktuell benannten Richtlinie. Feldfilter können angegeben werden.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
removed := e.RemoveFilteredNamedGroupingPolicy("g", 0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const removed = await e.removeFilteredNamedGroupingPolicy('g', 0, 'alice')
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$removed = $e->removeFilteredNamedGroupingPolicy("g", 0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
removed = e.remove_filtered_named_grouping_policy("g", 0, "alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var removed = e.RemoveFilteredNamedGroupingPolicy("g", 0, "alice");
or
var removed = await e.RemoveFilteredNamedGroupingPolicyAsync("g", 0, "alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let removed = e.remove_filtered_named_groupingPolicy("g", 0, vec!["alice".to_owned()]).await?;
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean removed = e.removeFilteredNamedGroupingPolicy("g", 0, "alice");
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `UpdatePolicy()`

UpdatePolicy aktualisiert eine alte Richtlinie auf neue Richtlinien.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
updated, err := e.UpdatePolicy([]string{"eve", "data3", "read"}, []string{"eve", "data3", "write"})
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const update = await e.updatePolicy(["eve", "data3", "read"], ["eve", "data3", "write"]);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
updated = e.update_policy(["eve", "data3", "read"], ["eve", "data3", "write"])
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
boolean updated = e.updatePolicy(Arrays.asList("eve", "data3", "read"), Arrays.asList("eve", "data3", "write"));
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `UpdatePolicies()`

UpdatePolicies aktualisiert alle alten Richtlinien auf neue Richtlinien.

Zum Beispiel:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
updated, err := e.UpdatePolicies([][]string{{"eve", "data3", "read"}, {"jack", "data3", "read"}}, [][]string{{"eve", "data3", "write"}, {"jack", "data3", "write"}})
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
old_rules = [["eve", "data3", "read"], ["jack", "data3", "read"]]
new_rules = [["eve", "data3", "write"], ["jack", "data3", "write"]]

updated = e.update_policies(old_rules, new_rules)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `AddFunction()`

AddFunction fügt eine benutzerdefinierte Funktion hinzu.

For example:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
func CustomFunction(key1 string, key2 string) bool {
    if key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource" {
        return true
    } else if key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId" {
        return true
    } else {
        return false
    }
}

func CustomFunctionWrapper(args ...interface{}) (interface{}, error) {
    key1 := args[0].(string)
    key2 := args[1].(string)

    return bool(CustomFunction(key1, key2)), nil
}

e.AddFunction("keyMatchCustom", CustomFunctionWrapper)
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
function customFunction(key1, key2){
    if(key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource") {
        return true
    } else if(key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId") {
        return true
    } else {
        return false
    }
}

e.addFunction("keyMatchCustom", customFunction);
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
func customFunction($key1, $key2) {
    if ($key1 == "/alice_data2/myid/using/res_id" && $key2 == "/alice_data/:resource") {
        return true;
    } elseif ($key1 == "/alice_data2/myid/using/res_id" && $key2 == "/alice_data2/:id/using/:resId") {
        return true;
    } else {
        return false;
    }
}

func customFunctionWrapper(...$args){
    $key1 := $args[0];
    $key2 := $args[1];

    return customFunction($key1, $key2);
}

$e->addFunction("keyMatchCustom", customFunctionWrapper);
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
def custom_function(key1, key2):
    return ((key1 == "/alice_data2/myid/using/res_id" and key2 == "/alice_data/:resource") or (key1 == "/alice_data2/myid/using/res_id" and key2 == "/alice_data2/:id/using/:resId"))


e.add_function("keyMatchCustom", custom_function)
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
fn custom_function(key1: STring, key2: String) {
    key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data/:resource" || key1 == "/alice_data2/myid/using/res_id" && key2 == "/alice_data2/:id/using/:resId"
}


e.add_function("keyMatchCustom", custom_function);
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
public static class CustomFunc extends CustomFunction {
    @Override
    public AviatorObject call(Map<String, Object> env, AviatorObject arg1, AviatorObject arg2) {
        String key1 = FunctionUtils.getStringValue(arg1, env);
        String key2 = FunctionUtils.getStringValue(arg2, env);
        if (key1.equals("/alice_data2/myid/using/res_id") && key2.equals("/alice_data/:resource")) {
            return AviatorBoolean.valueOf(true);
        } else if (key1.equals("/alice_data2/myid/using/res_id") && key2.equals("/alice_data2/:id/using/:resId")) {
            return AviatorBoolean.valueOf(true);
        } else {
            return AviatorBoolean.valueOf(false);
        }
    }

    @Override
    public String getName() {
        return "keyMatchCustom";
    }
}

FunctionTest.CustomFunc customFunc = new FunctionTest.CustomFunc();
e.addFunction(customFunc.getName(), customFunc);
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `LoadFilteredPolicy()`

LoadFilteredPolicy lädt gefilterte Richtlinien aus der Datei/Datenbank.

For example:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
err := e.LoadFilteredPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const ok = await e.loadFilteredPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
class Filter:
    P = []
    G = []

adapter = casbin.persist.adapters.FilteredAdapter("rbac_with_domains_policy.csv")
e = casbin.Enforcer("rbac_with_domains_model.conf", adapter)
filter = Filter()
filter.P = ["", "domain1"]
filter.G = ["", "", "domain1"]
e.load_filtered_policy(filter)
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
e.loadFilteredPolicy(new String[] { "", "domain1" });
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `LoadIncrementalFilteredPolicy()`

LoadIncrementalFilteredPolicy fügt eine gefilterte Richtlinie aus der Datei/Datenbank hinzu.

For example:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
err := e.LoadIncrementalFilteredPolicy()
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```typescript
const ok = await e.loadIncrementalFilteredPolicy();
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
adapter = casbin.persist.adapters.FilteredAdapter("rbac_with_domains_policy.csv")
e = casbin.Enforcer("rbac_with_domains_model.conf", adapter)
filter = Filter()
filter.P = ["", "domain1"]
filter.G = ["", "", "domain1"]
e.load_increment_filtered_policy(filter)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `UpdateGroupingPolicy()`

UpdateGroupingPolicy aktualisiert alte Regeln auf newRulein `g Abschnitt`

For example:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
succeed, err : = e.UpdateGroupingPolicy([]string{"data3_admin", "data4_admin"}, []string{"admin", "data4_admin"})
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```Java
boolean succeed = e.updateGroupingPolicy(Arrays.asList("data3_admin", "data4_admin"), Arrays.asList("admin", "data4_admin"));
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `UpdateNamedGroupingPolicy()`

UpdateNamedGroupingPolicy aktualisiert alte Regeln mit dem Namen `ptype` auf newRulein `g` Abschnitt

For example:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
succeed, err : = e.UpdateGroupingPolicy("g1",[]string{"data3_admin", "data4_admin"}, []string{"admin", "data4_admin"})
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```Java
boolean succeed = e.updateNamedGroupingPolicy("g1", Arrays.asList("data3_admin", "data4_admin"), Arrays.asList("admin", "data4_admin"));
```

```mdx-code-block
</TabItem>
</Tabs>
```

### `SetFieldIndex()`

SetFieldIndex suport customization of conventional name and position of `sub`, `obj`, `domain` and `priority`.

```ini
[policy_definition]
p = customized_priority, obj, act, eft, subject
```

For example:

```mdx-code-block
<Tabs>
<TabItem value="Go" label="Go" default>
```

```go
e.SetFieldIndex("p", constant.PriorityIndex, 0)
e.SetFieldIndex("p", constant.SubjectIndex, 4)
```

```mdx-code-block
</TabItem>
</Tabs>
```
