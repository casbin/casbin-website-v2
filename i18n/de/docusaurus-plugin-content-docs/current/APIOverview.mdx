---
id: api-overview
title: API-Übersicht
description: Casbin API usage
keywords:
  - API overview
  - API
  - API usage
authors:
  - hsluoyz
---

Diese Übersicht zeigt Ihnen nur, wie Sie Casbin APIs verwenden und erklärt nicht, wie Casbin installiert wird und wie es funktioniert. Diese Tutorials finden Sie hier: [Installation von Casbin](/docs/get-started) und [wie Casbin funktioniert](/docs/how-it-works). Wenn Sie also anfangen, dieses Tutorial zu lesen, gehen wir davon aus, dass Sie Casbin vollständig installiert und in Ihren Code importiert haben.

## API erzwingen

Beginnen wir mit den erzwungenen APIs von Casbin. Wir laden ein RBAC-Modell von `model.conf`und laden Richtlinien von `policy.csv`. You can learn the Model syntax [here](/docs/syntax-for-models), and we won't talk about it in this tutorial. Wir gehen davon aus, dass Sie die folgenden Konfigurationsdateien verstehen können:

`model.conf`

```ini
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
```

`policy.csv`

```
p, admin, data1, read
p, admin, data1, write
p, admin, data2, read
p, admin, data2, write
p, alice, data1, read
p, bob, data2, write
g, amber, admin
g, abc, admin
```

Nachdem Sie die Konfigurationsdateien gelesen haben, lesen Sie bitte den folgenden Code.

```go
// Lade Informationen aus Dateien
enforcer, err := casbin.NewEnforcer("./example/model.conf", "./example/policy. sv")
if err != nil {
    log. atalf("error, detail: %s", err)
}
ok, err := enforcer.Enforce("alice", "data1", "read")
```

Dieser Code lädt das Zugriffskontrollmodell und die Richtlinien aus lokalen Dateien. Funktion `casbin.NewEnforcer()` gibt einen Vollstrecker zurück. Es erkennt seine 2 Parameter als Dateipfade und lädt die Dateien von dort. Fehler im Prozess wurden in `err` gespeichert. Dieser Code benutzt den Standard-Adapter, um Modell und Richtlinien zu laden. Und natürlich können Sie das gleiche Ergebnis mit Hilfe eines Drittanbieter-Adapters erzielen.

Code `ok, err := enforcer.Enforce("alice", "data1", "read")`  soll Zugriffsberechtigungen bestätigen. Wenn der Alice auf die Daten 1 mit gelesener Operation zugreifen kann, der zurückgegebene Wert `ok` wird `true`sein, andernfalls ist er `false`. In diesem Beispiel ist der Wert von `ok` `true`.

## EnforceEx API

Manchmal kann man sich fragen, welche Politik die Anfrage erlaubt hat, deshalb haben wir die Funktion `EnforceEx()` vorbereitet. Sie können es so verwenden:

```go
ok, reason, err := enforcer.EnforceEx("amber", "data1", "read")
fmt.Println(ok, Grund) // true [admin data1 read]
```

Funktion `EnforceEx()` gibt den exakten Richtlinienstring im Rückgabewert `Grund` zurück. In diesem Beispiel ist `Bernstein` eine Rolle von `admin`, so Policy `p, admin, data1, lesen Sie` hat diese Anfrage `true`. Das Output dieses Codes ist in dem Kommentar.

Casbin bereitete eine Menge solcher APIs vor. Diese APIs haben einige zusätzliche Funktionen auf der Basis hinzugefügt. Sie sind:

- `ok, err := enforcer.EnforceWithMatcher(matcher, request)`

  Mit einem Matcher.

- `ok, reason, err := enforcer.EnforceExWithMatcher(matcher, request)`

  Eine Kombination von `EnforceWithMatcher()` und `EnforceEx()`.

- `boolArray, err := enforcer.BatchEnforce(requests)`

  Führe einen Listenauftrag aus, gibt ein Array zurück.

Dies ist eine einfache Verwendung von Casbin. Sie können Casbin benutzen, um einen Autorisierungsserver über diese API zu starten. Wir zeigen Ihnen einige andere APIs in den nächsten Absätzen.

## Management-API

### Get API

Diese APIs werden verwendet, um exakte Objekte in Richtlinien zu erhalten. Dieses Mal haben wir einen Vollstrecker wie das letzte Beispiel geladen und bekommen etwas davon.

Bitte lesen Sie den folgenden Code:

```go
enforcer,err := casbin.NewEnforcer("./example/model.conf", "./example/policy.csv")
if err != nil {
    fmt.Printf("Error, details: %s\n", err)
}
allSubjects := enforcer.GetAllSubjects()
fmt.Println(allSubjects)
```

Wie das letzte Beispiel haben auch die ersten 4 Zeilen einige notwendige Informationen aus lokalen Dateien geladen. Darüber werden wir hier nicht mehr reden.

Code `allSubjects := enforcer.GetAllSubjects()` hat alle Subjekte in der Richtlinien-Datei erhalten und sie als Array zurückgegeben. Dann haben wir dieses Array gedruckt.

Normalerweise sollte die Ausgabe des Codes sein:

```
[admin alice bob]
```

Sie können auch die Funktion `GetAllSubjects()` zu `GetAllNamedSubjects()` ändern, o holt die Liste der Themen, die in den aktuell benannten Richtlinien erscheinen.

Ebenso haben wir `GetAll-` Funktionen für `Objekte, Aktionen, Rollen` vorbereitet. Das einzige, was Sie tun müssen, ist, das Wort `Betreff` im Funktionsnamen in das zu ändern, was Sie wollen, wenn Sie auf diese Funktionen zugreifen möchten.

Außerdem haben wir mehr Entscheidungsträger für die Politik. Die Rufmethode und der Rückgabewert ähneln denen oben.

- `policy = e.GetPolicy()` erhält alle Berechtigungsregeln in der Richtlinie.
- `filteredPolicy := e.GetFilteredPolicy(0, "alice")` holt alle Autorisierungsregeln in der Richtlinie, Feldfilter können angegeben werden.
- `namedPolicy := e.GetNamedPolicy("p")` erhält alle Autorisierungsregeln in der angegebenen Richtlinie.
- `filteredNamedPolicy = e.GetFilteredNamedPolicy("p", 0, "bob")` holt alle Autorisierungsregeln in den genannten Richtlinien, Feldfilter können angegeben werden.
- `groupingPolicy := e.GetGroupingPolicy()` holt alle Rollenvererbungsregeln in der Richtlinie.
- `filteredGroupingPolicy := e.GetFilteredGroupingPolicy(0, "alice")` erhält alle Rollenvererbungsregeln in der Richtlinie, Feldfilter können angegeben werden.
- `namedGroupingPolicy := e.GetNamedGroupingPolicy("g")` holt alle Rollenvererbungsregeln in der Richtlinie.
- `namedGroupingPolicy := e.GetFilteredNamedGroupingPolicy("g", 0, "alice")` erhält alle Rollenvererbungsregeln in der Richtlinie.

### API hinzufügen, löschen, Update API

Casbin bereitete eine Menge APIs für Richtlinien vor. Mit diesen APIs können Sie Richtlinien zur Laufzeit dynamisch hinzufügen, löschen oder bearbeiten.

Dieser Code zeigt Ihnen, wie Sie Ihre Richtlinien hinzufügen, entfernen und aktualisieren und wie Sie bestätigen können, dass eine Richtlinie existiert:

```go
// Lade Informationen aus Dateien
enforcer,err := casbin.NewEnforcer("./example/model.conf", "./example/policy.csv")
if err != nil {
   fmt. rintf("Error, details: %s\n", err)
}

// Richtlinien hinzufügen, dann HasPolicy() verwenden, um zu bestätigen, dass
Vollstreckung durchgesetzt wird. ddPolicy("added_user", "data1", "read")
hasPolicy := enforcer.HasPolicy("added_user", "data1", "read")
fmt. rintln(hasPolicy) // true haben wir hinzugefügt, dass die Richtlinie erfolgreich

// eine Richtlinie entfernen und dann HasPolicy() verwenden, um zu bestätigen, dass
durchgesetzt wird. emovePolicy("alice", "data1", "read")
hasPolicy = enforcer.HasPolicy("alice", "data1", "read")
fmt. rintln(hasPolicy) // falsch, wir haben diese Richtlinie erfolgreich gelöscht

// Richtlinien aktualisieren und dann HasPolicy() verwenden, um zu bestätigen, dass
Durchsetzer ist. pdatePolicy([]string{"added_user", "data1", "read"}, []string{"added_user", "data1", "write"})
hasPolicy = enforcer.HasPolicy("added_user", "data1", "read")
fmt. rintln(hasPolicy) // falsch, die Ursprungsrichtlinie ist abgelaufen
hasPolicy = enforcer.HasPolicy("added_user", "data1", "write")
fmt.Println(hasPolicy) // true the new policy is in use
```

Mit diesen vier Arten von APIs können Sie Ihre Richtlinien bearbeiten. Wie diese haben wir die gleichen Arten von APIs für `FilteredPolicy, NamedPolicy, FilteredNamedPolicy, GroupingPolicy, NamedGroupingPolicy, FilteredGroupingPolicy, FilteredNamedGroupingPolicy` vorbereitet. Um sie zu verwenden, müssen Sie nur das Wort `Richtlinie` im Funktionsnamen zu den obigen Wörtern ersetzen.

Wenn Sie außerdem Parameter in Arrays ändern, können Sie Ihre Richtlinien Batch bearbeiten.

Zum Beispiel für Funktionen wie diese:

```go
enforcer.UpdatePolicy([]string{"eve", "data3", "read"}, []string{"eve", "data3", "write"})
```

wenn wir `Richtlinien` zu `Richtlinien`ändern und den Parameter bearbeiten:

```go
enforcer.UpdatePolicies([][]string{{"eve", "data3", "read"}, {"jack", "data3", "read"}}, [][]string{{"eve", "data3", "write"}, {"jack", "data3", "write"}})
```

dann können wir diese Richtlinien Batch bearbeiten.

Gleiche Operationen sind auch nützlich für `GroupingPolicy, NamedGroupingPolicy`.

### AddEx API

Casbin provides AddEx series APIs to help users add rules in batches.

```go
AddPoliciesEx(rules [][]string) (bool, error)
AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error)
AddGroupingPoliciesEx(rules [][]string) (bool, error)
AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error)
SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) 
```
The difference between these methods and the methods without the Ex suffix is that if one of the rules already exists, they will continue to check the next rule instead of returning false directly.

For example: Compare `AddPolicies` and `AddPoliciesEx`

You can copy the code below into the test under casbin to run and observe.
```go
func TestDemo(t *testing.T) {
    e, err := NewEnforcer("examples/basic_model.conf", "examples/basic_policy.csv")
    if err != nil {
        fmt.Printf("Error, details: %s\n", err)
    }
    e.ClearPolicy()
    e.AddPolicy("user1", "data1", "read")
    fmt.Println(e.GetPolicy())
    testGetPolicy(t, e, [][]string{{"user1", "data1", "read"}})

    // policy {"user1", "data1", "read"} now exists

    // Use AddPolicies to add rules in batches
    ok, _ := e.AddPolicies([][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
    fmt.Println(e.GetPolicy())
    // {"user2", "data2", "read"} failed to add because {"user1", "data1", "read"} already exists
    // AddPolicies returns false and no other policies are checked, even though they may not exist in the existing ruleset
    // ok == false
    fmt.Println(ok)
    testGetPolicy(t, e, [][]string{{"user1", "data1", "read"}})

    // Use AddPoliciesEx to add rules in batches
    ok, _ = e.AddPoliciesEx([][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
    fmt.Println(e.GetPolicy())
    // {"user2", "data2", "read"} is added successfully
    // because AddPoliciesEx automatically filters the existing {"user1", "data1", "read"}
    // ok == true
    fmt.Println(ok)
    testGetPolicy(t, e, [][]string{{"user1", "data1", "read"}, {"user2", "data2", "read"}})
}
```

## RBAC API

Casbin stellt Ihnen APIs zur Verfügung, um das RBAC-Modell und -Richtlinien zu ändern. Wenn Sie mit RBAC vertraut sind, können Sie diese APIs einfach verwenden.

Hier zeigen wir Ihnen nur wie Sie die RBAC APIs von Casbin verwenden und sprechen nicht über RBAC selbst. Weitere Details erhalten Sie [hier](/docs/rbac).

Wir verwenden diesen Code, um Modell und Richtlinien wie zuvor zu laden.

```go
enforcer,err := casbin.NewEnforcer("./example/model.conf", "./example/policy.csv")
if err != nil {
    fmt.Printf("Error, details: %s\n", err)
}
```

dann verwenden Sie eine Instanz des Vollstreckenden `Enforcer` um auf diese APIs zuzugreifen.

```go
roles, err := enforcer.GetRolesForUser("amber")
fmt.Println(roles) // [admin]
Benutzer, err := enforcer.GetUsersForRole("admin")
fmt.Println(users) // [amber abc]
```

`GetRolesForUser()` hat ein Array zurückgegeben, das alle Rollen enthielt, die Amber enthalten. In diesem Beispiel hat Bernstein nur einen Rollen-Admin, also sind `Rollen` `[admin]`. Und ähnlich können Sie `GetUsersForRole()` verwenden, um Benutzer zur Rolle zu bringen. Der Rückgabewert dieser Funktion ist auch ein Array.

```go
enforcer.HasRoleForUser("amber", "admin") // true
```

Sie können `HasRoleForUser()` verwenden, um zu bestätigen, ob der Benutzer zur Rolle gehört. In diesem Beispiel ist Bernstein Mitglied des Admins, also ist der Rückgabewert der Funktion `true`.

```go
fmt.Println(enforcer.Enforce("bob", "data2", "write")) // true
enforcer.DeletePermission("data2", "write")
fmt.Println(enforcer.Enforce("bob", "data2", "write")) // false
```

Sie können `DeletePermission()` verwenden, um eine Berechtigung zu löschen.

```go
fmt.Println(enforcer.Enforce("alice", "data1", "read")) // true
enforcer.DeletePermissionForUser("alice", "data1", "read")
fmt.Println(enforcer.Enforce("alice", "data1", "read")) // false false
```

Und verwenden Sie `DeletePermissionForUser()` um eine Berechtigung für einen Benutzer zu löschen.

Casbin hat viele APIs wie diese. Ihre Rufmethoden und Rückgabewerte haben den gleichen Stil wie die oben genannten APIs. Diese APIs finden Sie in [nächsten Dokumenten](/docs/rbac-api).
