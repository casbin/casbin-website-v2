---
id: get-started
title: Commencer
description: Getting started with Casbin
keywords:
  - Casbin
  - get started
  - installation
  - usage
authors:
  - nodece
---



## Installation

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```
allez obtenir github.com/casbin/casbin/v2
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

Pour Maven :

```xml
<!-- https://mvnrepository.com/artifact/org.casbin/jcasbin -->
<dependency>
    <groupId>org.casbin</groupId>
    <artifactId>jcasbin</artifactId>
    <version>1.x.y</version>
</dependency>
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```bash
# NPM
npm install casbin --save

# Yarn
yarn add casbin
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

Requiert ce package dans le `composer.json` de votre projet. Ceci va télécharger le paquet:

```bash
compositeur ont besoin de casbin/casbin
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```bash
pip install casbin
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```


```bash
dotnet add package Casbin.NET
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```bash
# télécharger la source
git clone https://github.com/casbin/casbin-cpp. il

# générer des fichiers de projet
cd casbin-cpp && mkdir build && cd build && cmake .. -DCMAKE_BUILD_TYPE=Release

# build and install casbin
cmake --build . --config Release --target casbin install -j 10
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```bash
cargo install cargo-edit
cargo add casbin

// If you use async-std as async executor
cargo add async-std

// If you use tokio as async executor
cargo add tokio // make sure you activate its `macros` feature
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

Casbin4D est disponible dans un paquet (actuellement pour Delphi 10.3 Rio) et vous pouvez l'installer dans l'IDE. Cependant, il n'y a pas de composants visuels ce qui signifie que vous pouvez utiliser les unités indépendamment des paquets. Il vous suffit d'importer les unités de votre projet (en supposant que le nombre de ces unités ne vous dérange pas).

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```bash
luarocks installer casbin  
```

Si erreur de rapport : votre utilisateur n'a pas les permissions d'écriture dans /usr/local/lib/luarocks/rocks -- vous pouvez utiliser votre arborescence locale avec --local. vous pouvez ajouter --local derrière votre commande pour corriger :

```bash
luarocks installe casbin --local
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Un nouveau responsable de Casbin

Casbin utilise des fichiers de configuration pour définir le modèle de contrôle d'accès.

Il a deux fichiers de configuration, `model.conf` et `policy.csv`. Parmi eux, `model.conf` stocke notre modèle d'accès, et `policy.csv` stocke notre configuration spécifique de permission d'utilisateur. L'utilisation de Casbin est très raffinée. Fondamentalement, nous avons juste besoin d'une structure principale : **enforcecer**. Lors de la construction de cette structure, `model.conf` et `policy.csv` seront chargés.

En un autre mot, pour un nouvel agent de sécurité Casbin, vous devez fournir un [modèle](supported-models) et un [adaptateur](adapters).

Casbin has a [FileAdapter](adapters#file-adapter-built-in), see [Adapter](adapters) for more information.

- Utiliser le fichier modèle et la valeur par défaut [FileAdapter](adapters#file-adapter-built-in):

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
import "github.com/casbin/casbin/v2"

e, err := casbin.NewEnforcer("path/to/model.conf", "path/to/policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
import org.casbin.jcasbin.main.Enforcer;

Enforcer e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```javascript
import { newEnforcer } from 'casbin';

const e = await newEnforcer('path/to/model.conf', 'path/to/policy.csv');
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
require_once './vendor/autoload.php';

use Casbin\Enforcer;

$e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
import casbin

e = casbin.Enforcer("path/to/model.conf", "path/to/policy.csv")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
using NetCasbin; 

var e = new Enforcer("path/to/model.conf", "path/to/policy.csv");
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```cpp
#include <iostream>
#include <casbin/casbin.h>

int main() {
    // Créer un moteur
    casbin::Enforcer e("path/to/model.conf", "path/to/policy.csv");

    // votre code ..
}
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
var
  casbin: ICasbin;
begin
  casbin := TCasbin.Create('path/to/model.conf', 'path/to/policy.csv');
  ...
end
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
use casbin::prelude::*;

// If you use async_td as async executor
#[cfg(feature = "runtime-async-std")]
#[async_std::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}

// If you use tokio as async executor
#[cfg(feature = "runtime-tokio")]
#[tokio::main]
async fn main() -> Result<()> {
    let mut e = Enforcer::new("path/to/model.conf", "path/to/policy.csv").await?;
    Ok(())
}
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
local Enforcer = require("casbin")
local e = Enforcer:new("path/to/model.conf", "path/to/policy.csv") -- The Casbin Enforcer
```

```mdx-code-block
</TabItem>
</Tabs>
```

- Utiliser le texte du modèle avec un autre adaptateur:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
import (
    "log"

    "github.com/casbin/casbin/v2"
    "github.com/casbin/casbin/casbin/v2/model"
    xormadapter "github.com/casbin/xorm-adapter/v2"
    _ "github.com/go-sql-driver/mysql"
)

// Initialise un adaptateur Xorm avec une base de données MySQL.
a, err := xormadapter.NewAdapter("mysql", "mysql_username:mysql_password@tcp(127.0.0. :3306)/casbin")
if err != nil {
    log.Fatalf("error: adapter: %s", err)
}

m, err := model. ewModelFromString(`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[policy_effect]
e = some(where (p. ft == allow))

[matchers]
m = r.sub == p.sub && r.obj == p. bj && r.act == p.act
`)
if err != nil {
    log. atalf("erreur: modèle : %s", err)
}

e, err := casbin. ewEnforcer(m, a)
if err != nil {
    log.Fatalf("error: enforcer: %s", err)
}
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
import casbin
import casbin_sqlalchemy_adapter


# Utiliser l'adaptateur SQLAlchemy Casbin avec SQLLite DB
adaptateur = casbin_sqlalchemy_adapter. dapter('sqlite:///test.db')

# Créez une charte de modèle de configuration
avec open("rbac_example_model.conf", "w") comme f:
    f. rite("""
    [request_definition]
    r = sub, obj, act

    [policy_definition]
    p = sub, obj, act

    [policy_effect]
    e = quelque part (où (p. ft == allow))

    [matchers]
    m = r. ub == p.sub && r.obj == p.obj && r.act == p. ct
    """)

# Créer un enforcer à partir de l'adaptateur et de la politique de configuration
e = casbin.Enforcer('rbac_example_model.conf', adaptateur)
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Vérifier les autorisations

Ajoutez un crochet d'application à votre code juste avant que l'accès ne se produise :

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
sub := "alice" // l'utilisateur qui veut accéder à une ressource.
obj := "data1" // la ressource qui va être accédée.
act := "read" // l'opération que l'utilisateur effectue sur la ressource.

ok, erreur := e. nforce(sub, obj, act)

si erreur! nil {
    // handle err
}

if ok == true {
    // autorise alice à lire les données 1
} else {
    // refuse la requête, affiche une erreur
}

// Vous pouvez utiliser BatchEnforce() pour imposer certaines requêtes en lots.
// Cette méthode retourne une tranche de booléen, et l'index de cette tranche correspond à l'index de ligne du tableau en deux dimensions.
// par exemple les résultats[0] sont le résultat de {"alice", "data1", "read"}
résultats, erreur:= e.BatchEnforce([][]interface{}{{"alice", "data1", "read"}, {"bob", "data2", "write"}, {"jack", "data3", "read"}})
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
String sub = "alice"; // l'utilisateur qui veut accéder à une ressource.
String obj = "data1"; // la ressource qui va être accédée.
String act = "read"; // l'opération que l'utilisateur effectue sur la ressource.

if (e. nforce(sub, obj, act) == true) {
    // autorise alice à lire les données1
} else {
    // refuse la requête, afficher une erreur
}
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```js
const sub = 'alice'; // l'utilisateur qui veut accéder à une ressource.
const obj = 'data1'; // la ressource qui va être accédée.
const act = 'read'; // l'opération que l'utilisateur effectue sur la ressource.

if (attendez e. nforce(sub, obj, act)) === true) {
    // autorise alice à lire les données1
} else {
    // refuse la requête, afficher une erreur
}
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$sub = "alice"; // l'utilisateur qui veut accéder à une ressource.
$obj = "data1"; // la ressource qui va être accédée.
$act = "read"; // l'opération que l'utilisateur effectue sur la ressource.

if ($e->enforce($sub, $obj, $act) === true) {
    // autorise alice à lire les données 1
} else {
    // refuse la requête, afficher une erreur
}
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
sub = "alice" # l'utilisateur qui veut accéder à une ressource.
obj = "data1" # la ressource qui va être accédée.
act = "read" # l'opération que l'utilisateur effectue sur la ressource.

if e.enforce(sub, obj, act):
    # permet alice de lire les données1
    passe
else:
    # refuse la requête, affiche une erreur
    passe
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var sub = "alice"; # l'utilisateur qui veut accéder à une ressource.
var obj = "data1"; # la ressource qui va être accédée.
var act = "read"; # l'opération que l'utilisateur effectue sur la ressource.

if (attendre e. nforceAsync(sub, obj, act)) 
{
    // autorise alice à lire les données 1
}
else
{
    // refuse la requête, afficher une erreur
}
```

```mdx-code-block
</TabItem>
<TabItem value="C++" label="C++">
```

```cpp
    casbin::Enforcer e("../assets/model.conf", "../assets/policy.csv");

    if (e. nforce({"alice", "/alice_data/bonjour", "GET"})) {
        std::cout << "Forcer OK" << std::endl;
    } else {
        std::cout << "Force NOT Good" << std::endl;
    }

    if (e. nforce({"alice", "/alice_data/bonjour", "POST"})) {
        std::cout << "Forcer OK" << std::endl;
    } else {
        std::cout << "Force NOT Good" << std::endl;
}
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
if casbin.enforce(['alice,data1,read']) then
  // Alice est super heureuse car elle peut lire les données1
else
  // Alice est triste
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
  let sub = "alice"; // l'utilisateur qui veut accéder à une ressource.
  let obj = "data1"; // la ressource qui va être accédée.
  let act = "read"; // l'opération que l'utilisateur effectue sur la ressource.

  if e.enforce(sub, obj, act)).await? {
      // autorise alice à lire les données1
  } else {
      // erreur survient
}
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
if e:enforce("alice", "data1", "read") then
   -- allow alice to read data1
else
   -- deny the request, show an error
end

```

```mdx-code-block
</TabItem>
</Tabs>
```

Casbin fournit également une API pour la gestion des permissions à l'exécution. Par exemple, vous pouvez obtenir tous les rôles assignés à un utilisateur comme ci-dessous:

```mdx-code-block
<Tabs groupId="langs">
<TabItem value="Go" label="Go" default>
```

```go
roles, err := e.GetRolesForUser("alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Java" label="Java">
```

```java
List<String> roles = e.getRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Node.js" label="Node.js">
```

```javascript
const roles = await e.getRolesForUser('alice');
```

```mdx-code-block
</TabItem>
<TabItem value="PHP" label="PHP">
```

```php
$roles = $e->getRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Python" label="Python">
```

```python
roles = e.get_roles_for_user("alice")
```

```mdx-code-block
</TabItem>
<TabItem value=".NET" label=".NET">
```

```csharp
var roles = e.GetRolesForUser("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Delphi" label="Delphi">
```

```delphi
roles = e.rolesForEntity("alice")
```

```mdx-code-block
</TabItem>
<TabItem value="Rust" label="Rust">
```

```rust
let roles = e.get_roles_for_user("alice");
```

```mdx-code-block
</TabItem>
<TabItem value="Lua" label="Lua">
```

```lua
local roles = e:GetRolesForUser("alice")
```

```mdx-code-block
</TabItem>
</Tabs>
```

Voir [Management API](/docs/management-api) et [RBAC API](/docs/rbac-api) pour plus d'utilisation.

Veuillez vous référer aux cas de test pour plus d'usage.
